{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nornir_scrapli \u00b6 nornir_scrapli -- scrapli 's and scrapli_netconf 's plugin for nornir!","title":"Nornir Scrapli"},{"location":"#nornir_scrapli","text":"nornir_scrapli -- scrapli 's and scrapli_netconf 's plugin for nornir!","title":"nornir_scrapli"},{"location":"about/code_of_conduct/","text":"Code of Conduct \u00b6 Be excellent to each other!","title":"Code of Conduct"},{"location":"about/code_of_conduct/#code-of-conduct","text":"Be excellent to each other!","title":"Code of Conduct"},{"location":"about/contributing/","text":"Contributing \u00b6 Thanks for thinking about contributing! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR, this way everyone has a chance to chime in and make sure we're all on the same page! Please open an issue to discuss any bugs/bug fixes prior to opening a PR. Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated! All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"about/contributing/#contributing","text":"Thanks for thinking about contributing! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR, this way everyone has a chance to chime in and make sure we're all on the same page! Please open an issue to discuss any bugs/bug fixes prior to opening a PR. Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated! All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"api_docs/connection/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module nornir_scrapli.connection \u00b6 nornir_scrapli.connection Expand source code \"\"\"nornir_scrapli.connection\"\"\" from typing import TYPE_CHECKING, Any, Dict, Optional from scrapli import Scrapli from scrapli.driver import GenericDriver from scrapli.exceptions import ScrapliModuleNotFound from scrapli_cfg import ScrapliCfg from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_netconf.driver import NetconfDriver from nornir.core.configuration import Config from nornir.core.task import Task from nornir_scrapli.exceptions import NornirScrapliInvalidPlatform if TYPE_CHECKING: from nornir.core.plugins.connections import ConnectionPlugin # pylint: disable=C0412 CONNECTION_NAME = \"scrapli\" PLATFORM_MAP = { \"ios\": \"cisco_iosxe\", \"nxos\": \"cisco_nxos\", \"iosxr\": \"cisco_iosxr\", \"eos\": \"arista_eos\", \"junos\": \"juniper_junos\", } class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"'platform' not provided in inventory for host `{hostname}`\" ) final_platform: str = PLATFORM_MAP.get(platform, platform) if final_platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=final_platform) except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{final_platform}` is not a valid scrapli or napalm \" \"platform, or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close() class ScrapliConfig: \"\"\"Scrapli connection plugin for nornir\"\"\" connection: ScrapliCfgPlatform @staticmethod def get_connection(task: Task) -> ScrapliCfgPlatform: \"\"\" Try to fetch scrapli-cfg conn, create it if it doesnt exist This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliCfg Raises: N/A \"\"\" connection: ScrapliCfgPlatform try: connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) except AttributeError: task.host.connections[\"scrapli_cfg\"] = ScrapliConfig.spawn(task=task) connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) return connection @staticmethod def spawn(task: Task) -> \"ConnectionPlugin\": \"\"\" Spawn a ScrapliConfig object for a nornir host This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliConfig Raises: N/A \"\"\" scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config) scrapli_cfg_parameters = task.host.get_connection_parameters(connection=\"scrapli_cfg\") # should always be a dict afaik, but typing doesnt appreciate the possibility it is None extras = scrapli_cfg_parameters.extras or {} # always overwrite `dedicated_connection` as we are *not* having a dedicated connection # since we are wrapping the \"normal\" scrapli connection! extras[\"dedicated_connection\"] = False final_scrapli_cfg_parameters: Dict[str, Any] = { \"conn\": scrapli_conn, **extras, } connection = ScrapliCfg(**final_scrapli_cfg_parameters) scrapli_config_connection_obj = ScrapliConfig() scrapli_config_connection_obj.connection = connection scrapli_config_connection_obj.open() return scrapli_config_connection_obj def open(self, *args: Any, **kwargs: Any) -> None: \"\"\" Override open method of normal nornir connection so we can coopt an existing conn Args: args: args for not dealing w/ overridden hings kwargs: kwargs for not dealing w/ overridden hings Returns: None Raises: N/A \"\"\" _, _ = args, kwargs self.connection.prepare() def close(self) -> None: \"\"\" Override close method of normal nornir connection so we never close things Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn Args: N/A Returns: None Raises: N/A \"\"\" class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close() Classes \u00b6 ScrapliConfig \u00b6 1 Scrapli connection plugin for nornir Expand source code class ScrapliConfig: \"\"\"Scrapli connection plugin for nornir\"\"\" connection: ScrapliCfgPlatform @staticmethod def get_connection(task: Task) -> ScrapliCfgPlatform: \"\"\" Try to fetch scrapli-cfg conn, create it if it doesnt exist This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliCfg Raises: N/A \"\"\" connection: ScrapliCfgPlatform try: connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) except AttributeError: task.host.connections[\"scrapli_cfg\"] = ScrapliConfig.spawn(task=task) connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) return connection @staticmethod def spawn(task: Task) -> \"ConnectionPlugin\": \"\"\" Spawn a ScrapliConfig object for a nornir host This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliConfig Raises: N/A \"\"\" scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config) scrapli_cfg_parameters = task.host.get_connection_parameters(connection=\"scrapli_cfg\") # should always be a dict afaik, but typing doesnt appreciate the possibility it is None extras = scrapli_cfg_parameters.extras or {} # always overwrite `dedicated_connection` as we are *not* having a dedicated connection # since we are wrapping the \"normal\" scrapli connection! extras[\"dedicated_connection\"] = False final_scrapli_cfg_parameters: Dict[str, Any] = { \"conn\": scrapli_conn, **extras, } connection = ScrapliCfg(**final_scrapli_cfg_parameters) scrapli_config_connection_obj = ScrapliConfig() scrapli_config_connection_obj.connection = connection scrapli_config_connection_obj.open() return scrapli_config_connection_obj def open(self, *args: Any, **kwargs: Any) -> None: \"\"\" Override open method of normal nornir connection so we can coopt an existing conn Args: args: args for not dealing w/ overridden hings kwargs: kwargs for not dealing w/ overridden hings Returns: None Raises: N/A \"\"\" _, _ = args, kwargs self.connection.prepare() def close(self) -> None: \"\"\" Override close method of normal nornir connection so we never close things Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn Args: N/A Returns: None Raises: N/A \"\"\" Class variables \u00b6 connection: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform Static methods \u00b6 get_connection \u00b6 get_connection(task: nornir.core.task.Task) \u2011> scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Try to fetch scrapli-cfg conn, create it if it doesnt exist This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliCfg Raises: N/A spawn \u00b6 spawn(task: nornir.core.task.Task) \u2011> ConnectionPlugin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Spawn a ScrapliConfig object for a nornir host This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliConfig Raises: N/A Methods \u00b6 close \u00b6 close(self) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 12 Override close method of normal nornir connection so we never close things Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn Args: N/A Returns: None Raises: N/A open \u00b6 open(self, *args: Any, **kwargs: Any) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 Override open method of normal nornir connection so we can coopt an existing conn Args: args: args for not dealing w/ overridden hings kwargs: kwargs for not dealing w/ overridden hings Returns: None Raises: N/A ScrapliCore \u00b6 1 Scrapli connection plugin for nornir Expand source code class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"'platform' not provided in inventory for host `{hostname}`\" ) final_platform: str = PLATFORM_MAP.get(platform, platform) if final_platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=final_platform) except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{final_platform}` is not a valid scrapli or napalm \" \"platform, or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close() Methods \u00b6 close \u00b6 close(self) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 Close a scrapli connection to a device Args: N/A Returns: None Raises: N/A open \u00b6 open(self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[nornir.core.configuration.Config] = None) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided ScrapliNetconf \u00b6 1 Scrapli NETCONF connection plugin for nornir Expand source code class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close() Methods \u00b6 close \u00b6 close(self) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 Close a scrapli netconf connection to a device Args: N/A Returns: None Raises: N/A open \u00b6 open(self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[nornir.core.configuration.Config] = None) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: N/A","title":"Connection"},{"location":"api_docs/connection/#module-nornir_scrapliconnection","text":"nornir_scrapli.connection Expand source code \"\"\"nornir_scrapli.connection\"\"\" from typing import TYPE_CHECKING, Any, Dict, Optional from scrapli import Scrapli from scrapli.driver import GenericDriver from scrapli.exceptions import ScrapliModuleNotFound from scrapli_cfg import ScrapliCfg from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_netconf.driver import NetconfDriver from nornir.core.configuration import Config from nornir.core.task import Task from nornir_scrapli.exceptions import NornirScrapliInvalidPlatform if TYPE_CHECKING: from nornir.core.plugins.connections import ConnectionPlugin # pylint: disable=C0412 CONNECTION_NAME = \"scrapli\" PLATFORM_MAP = { \"ios\": \"cisco_iosxe\", \"nxos\": \"cisco_nxos\", \"iosxr\": \"cisco_iosxr\", \"eos\": \"arista_eos\", \"junos\": \"juniper_junos\", } class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"'platform' not provided in inventory for host `{hostname}`\" ) final_platform: str = PLATFORM_MAP.get(platform, platform) if final_platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=final_platform) except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{final_platform}` is not a valid scrapli or napalm \" \"platform, or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close() class ScrapliConfig: \"\"\"Scrapli connection plugin for nornir\"\"\" connection: ScrapliCfgPlatform @staticmethod def get_connection(task: Task) -> ScrapliCfgPlatform: \"\"\" Try to fetch scrapli-cfg conn, create it if it doesnt exist This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliCfg Raises: N/A \"\"\" connection: ScrapliCfgPlatform try: connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) except AttributeError: task.host.connections[\"scrapli_cfg\"] = ScrapliConfig.spawn(task=task) connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) return connection @staticmethod def spawn(task: Task) -> \"ConnectionPlugin\": \"\"\" Spawn a ScrapliConfig object for a nornir host This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliConfig Raises: N/A \"\"\" scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config) scrapli_cfg_parameters = task.host.get_connection_parameters(connection=\"scrapli_cfg\") # should always be a dict afaik, but typing doesnt appreciate the possibility it is None extras = scrapli_cfg_parameters.extras or {} # always overwrite `dedicated_connection` as we are *not* having a dedicated connection # since we are wrapping the \"normal\" scrapli connection! extras[\"dedicated_connection\"] = False final_scrapli_cfg_parameters: Dict[str, Any] = { \"conn\": scrapli_conn, **extras, } connection = ScrapliCfg(**final_scrapli_cfg_parameters) scrapli_config_connection_obj = ScrapliConfig() scrapli_config_connection_obj.connection = connection scrapli_config_connection_obj.open() return scrapli_config_connection_obj def open(self, *args: Any, **kwargs: Any) -> None: \"\"\" Override open method of normal nornir connection so we can coopt an existing conn Args: args: args for not dealing w/ overridden hings kwargs: kwargs for not dealing w/ overridden hings Returns: None Raises: N/A \"\"\" _, _ = args, kwargs self.connection.prepare() def close(self) -> None: \"\"\" Override close method of normal nornir connection so we never close things Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn Args: N/A Returns: None Raises: N/A \"\"\" class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close()","title":"Module nornir_scrapli.connection"},{"location":"api_docs/connection/#classes","text":"","title":"Classes"},{"location":"api_docs/connection/#scrapliconfig","text":"1 Scrapli connection plugin for nornir Expand source code class ScrapliConfig: \"\"\"Scrapli connection plugin for nornir\"\"\" connection: ScrapliCfgPlatform @staticmethod def get_connection(task: Task) -> ScrapliCfgPlatform: \"\"\" Try to fetch scrapli-cfg conn, create it if it doesnt exist This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliCfg Raises: N/A \"\"\" connection: ScrapliCfgPlatform try: connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) except AttributeError: task.host.connections[\"scrapli_cfg\"] = ScrapliConfig.spawn(task=task) connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config) return connection @staticmethod def spawn(task: Task) -> \"ConnectionPlugin\": \"\"\" Spawn a ScrapliConfig object for a nornir host This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliConfig Raises: N/A \"\"\" scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config) scrapli_cfg_parameters = task.host.get_connection_parameters(connection=\"scrapli_cfg\") # should always be a dict afaik, but typing doesnt appreciate the possibility it is None extras = scrapli_cfg_parameters.extras or {} # always overwrite `dedicated_connection` as we are *not* having a dedicated connection # since we are wrapping the \"normal\" scrapli connection! extras[\"dedicated_connection\"] = False final_scrapli_cfg_parameters: Dict[str, Any] = { \"conn\": scrapli_conn, **extras, } connection = ScrapliCfg(**final_scrapli_cfg_parameters) scrapli_config_connection_obj = ScrapliConfig() scrapli_config_connection_obj.connection = connection scrapli_config_connection_obj.open() return scrapli_config_connection_obj def open(self, *args: Any, **kwargs: Any) -> None: \"\"\" Override open method of normal nornir connection so we can coopt an existing conn Args: args: args for not dealing w/ overridden hings kwargs: kwargs for not dealing w/ overridden hings Returns: None Raises: N/A \"\"\" _, _ = args, kwargs self.connection.prepare() def close(self) -> None: \"\"\" Override close method of normal nornir connection so we never close things Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn Args: N/A Returns: None Raises: N/A \"\"\"","title":"ScrapliConfig"},{"location":"api_docs/connection/#class-variables","text":"connection: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform","title":"Class variables"},{"location":"api_docs/connection/#static-methods","text":"","title":"Static methods"},{"location":"api_docs/connection/#get_connection","text":"get_connection(task: nornir.core.task.Task) \u2011> scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Try to fetch scrapli-cfg conn, create it if it doesnt exist This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliCfg Raises: N/A","title":"get_connection"},{"location":"api_docs/connection/#spawn","text":"spawn(task: nornir.core.task.Task) \u2011> ConnectionPlugin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Spawn a ScrapliConfig object for a nornir host This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it. Args: task: nornir Task object Returns: ScrapliConfig Raises: N/A","title":"spawn"},{"location":"api_docs/connection/#methods","text":"","title":"Methods"},{"location":"api_docs/connection/#close","text":"close(self) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 12 Override close method of normal nornir connection so we never close things Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn Args: N/A Returns: None Raises: N/A","title":"close"},{"location":"api_docs/connection/#open","text":"open(self, *args: Any, **kwargs: Any) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 Override open method of normal nornir connection so we can coopt an existing conn Args: args: args for not dealing w/ overridden hings kwargs: kwargs for not dealing w/ overridden hings Returns: None Raises: N/A","title":"open"},{"location":"api_docs/connection/#scraplicore","text":"1 Scrapli connection plugin for nornir Expand source code class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"'platform' not provided in inventory for host `{hostname}`\" ) final_platform: str = PLATFORM_MAP.get(platform, platform) if final_platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=final_platform) except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{final_platform}` is not a valid scrapli or napalm \" \"platform, or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close()","title":"ScrapliCore"},{"location":"api_docs/connection/#methods_1","text":"","title":"Methods"},{"location":"api_docs/connection/#close_1","text":"close(self) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 Close a scrapli connection to a device Args: N/A Returns: None Raises: N/A","title":"close"},{"location":"api_docs/connection/#open_1","text":"open(self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[nornir.core.configuration.Config] = None) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided","title":"open"},{"location":"api_docs/connection/#scraplinetconf","text":"1 Scrapli NETCONF connection plugin for nornir Expand source code class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: None Raises: N/A \"\"\" self.connection.close()","title":"ScrapliNetconf"},{"location":"api_docs/connection/#methods_2","text":"","title":"Methods"},{"location":"api_docs/connection/#close_2","text":"close(self) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 Close a scrapli netconf connection to a device Args: N/A Returns: None Raises: N/A","title":"close"},{"location":"api_docs/connection/#open_2","text":"open(self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[nornir.core.configuration.Config] = None) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: None Raises: N/A","title":"open"},{"location":"api_docs/exceptions/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module nornir_scrapli.exceptions \u00b6 nornir_scrapli.exceptions Expand source code \"\"\"nornir_scrapli.exceptions\"\"\" class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\" Classes \u00b6 NornirScrapliException \u00b6 1 nornir_scrapli base exception Expand source code class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\" Ancestors (in MRO) \u00b6 builtins.Exception builtins.BaseException Descendants \u00b6 nornir_scrapli.exceptions.NornirScrapliInvalidPlatform nornir_scrapli.exceptions.NornirScrapliNoConfigModeGenericDriver NornirScrapliInvalidPlatform \u00b6 1 nornir_scrapli base exception Expand source code class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\" Ancestors (in MRO) \u00b6 nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException NornirScrapliNoConfigModeGenericDriver \u00b6 1 nornir_scrapli exception for attempting config mode on generic platform Expand source code class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\" Ancestors (in MRO) \u00b6 nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException","title":"Exceptions"},{"location":"api_docs/exceptions/#module-nornir_scrapliexceptions","text":"nornir_scrapli.exceptions Expand source code \"\"\"nornir_scrapli.exceptions\"\"\" class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\"","title":"Module nornir_scrapli.exceptions"},{"location":"api_docs/exceptions/#classes","text":"","title":"Classes"},{"location":"api_docs/exceptions/#nornirscrapliexception","text":"1 nornir_scrapli base exception Expand source code class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\"","title":"NornirScrapliException"},{"location":"api_docs/exceptions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#descendants","text":"nornir_scrapli.exceptions.NornirScrapliInvalidPlatform nornir_scrapli.exceptions.NornirScrapliNoConfigModeGenericDriver","title":"Descendants"},{"location":"api_docs/exceptions/#nornirscrapliinvalidplatform","text":"1 nornir_scrapli base exception Expand source code class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\"","title":"NornirScrapliInvalidPlatform"},{"location":"api_docs/exceptions/#ancestors-in-mro_1","text":"nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#nornirscraplinoconfigmodegenericdriver","text":"1 nornir_scrapli exception for attempting config mode on generic platform Expand source code class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\"","title":"NornirScrapliNoConfigModeGenericDriver"},{"location":"api_docs/exceptions/#ancestors-in-mro_2","text":"nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/functions/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module nornir_scrapli.functions \u00b6 nornir_scrapli.functions Expand source code \"\"\"nornir_scrapli.functions\"\"\" from nornir_scrapli.functions.print_structured_result import print_structured_result __all__ = (\"print_structured_result\",) Functions \u00b6 print_structured_result \u00b6 print_structured_result(result: nornir.core.task.AggregatedResult, failed: bool = False, severity_level: int = 20, parser: str = 'textfsm', to_dict: bool = True, fail_to_string: bool = False) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 Prints the :obj:`nornir.core.task.Result` from a previous task to screen Arguments: result: Nornir AggregateResult object from a previous task failed: if `True` assume the task failed severity_level: Print only errors with this severity level or higher parser: textfsm|genie -- parser to parse output with to_dict: output structured data in dict form instead -- basically put k:v instead of just lists of lists of values for textfsm output; ignored if parser == \"genie\" fail_to_string: fallback to printing unstructured output or have tasks skipped (because print_result won't print empty lists which scrapli returns if parsing fails)","title":"Functions"},{"location":"api_docs/functions/#module-nornir_scraplifunctions","text":"nornir_scrapli.functions Expand source code \"\"\"nornir_scrapli.functions\"\"\" from nornir_scrapli.functions.print_structured_result import print_structured_result __all__ = (\"print_structured_result\",)","title":"Module nornir_scrapli.functions"},{"location":"api_docs/functions/#functions","text":"","title":"Functions"},{"location":"api_docs/functions/#print_structured_result","text":"print_structured_result(result: nornir.core.task.AggregatedResult, failed: bool = False, severity_level: int = 20, parser: str = 'textfsm', to_dict: bool = True, fail_to_string: bool = False) \u2011> NoneType 1 2 3 4 5 6 7 8 9 10 11 Prints the :obj:`nornir.core.task.Result` from a previous task to screen Arguments: result: Nornir AggregateResult object from a previous task failed: if `True` assume the task failed severity_level: Print only errors with this severity level or higher parser: textfsm|genie -- parser to parse output with to_dict: output structured data in dict form instead -- basically put k:v instead of just lists of lists of values for textfsm output; ignored if parser == \"genie\" fail_to_string: fallback to printing unstructured output or have tasks skipped (because print_result won't print empty lists which scrapli returns if parsing fails)","title":"print_structured_result"},{"location":"api_docs/helper/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module nornir_scrapli.helper \u00b6 nornir_scrapli.helper Expand source code \"\"\"nornir_scrapli.helper\"\"\" import difflib ANSI_GREEN = \"\\033[92m\" ANSI_RED = \"\\033[91m\" ANSI_END = \"\\033[0m\" def diff_xml_text(document_one: str, document_two: str) -> str: \"\"\" Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A \"\"\" # ignore message-id stuff -- maybe more in the future? document_one_lines = [line for line in document_one.splitlines() if \"message-id\" not in line] document_two_lines = [line for line in document_two.splitlines() if \"message-id\" not in line] diff = difflib.unified_diff(document_one_lines, document_two_lines) diff_lines = [] for line in diff: if line.startswith(\"---\") or line.startswith(\"+++\"): # may as well just strip out the header lines and such, we dont care about them continue if line.startswith(\"+\"): diff_lines.append(f\"{ANSI_GREEN}{line}{ANSI_END}\") elif line.startswith(\"-\"): diff_lines.append(f\"{ANSI_RED}{line}{ANSI_END}\") else: diff_lines.append(line) return \"\\n\".join(diff_lines) Functions \u00b6 diff_xml_text \u00b6 diff_xml_text(document_one: str, document_two: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A","title":"Helper"},{"location":"api_docs/helper/#module-nornir_scraplihelper","text":"nornir_scrapli.helper Expand source code \"\"\"nornir_scrapli.helper\"\"\" import difflib ANSI_GREEN = \"\\033[92m\" ANSI_RED = \"\\033[91m\" ANSI_END = \"\\033[0m\" def diff_xml_text(document_one: str, document_two: str) -> str: \"\"\" Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A \"\"\" # ignore message-id stuff -- maybe more in the future? document_one_lines = [line for line in document_one.splitlines() if \"message-id\" not in line] document_two_lines = [line for line in document_two.splitlines() if \"message-id\" not in line] diff = difflib.unified_diff(document_one_lines, document_two_lines) diff_lines = [] for line in diff: if line.startswith(\"---\") or line.startswith(\"+++\"): # may as well just strip out the header lines and such, we dont care about them continue if line.startswith(\"+\"): diff_lines.append(f\"{ANSI_GREEN}{line}{ANSI_END}\") elif line.startswith(\"-\"): diff_lines.append(f\"{ANSI_RED}{line}{ANSI_END}\") else: diff_lines.append(line) return \"\\n\".join(diff_lines)","title":"Module nornir_scrapli.helper"},{"location":"api_docs/helper/#functions","text":"","title":"Functions"},{"location":"api_docs/helper/#diff_xml_text","text":"diff_xml_text(document_one: str, document_two: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A","title":"diff_xml_text"},{"location":"api_docs/result/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module nornir_scrapli.result \u00b6 nornir_scrapli.result Expand source code \"\"\"nornir_scrapli.result\"\"\" from typing import TYPE_CHECKING, Any, Optional, Union from scrapli.response import MultiResponse, Response from scrapli_cfg.response import ScrapliCfgResponse from nornir.core.task import Result if TYPE_CHECKING: from nornir.core.inventory import Host # pylint: disable=C0412 def process_command_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" if isinstance(scrapli_response, Response): result: str = scrapli_response.result return result return \"\\n\\n\".join([response.result for response in scrapli_response]) def process_config_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" full_results = \"\" if isinstance(scrapli_response, Response): for config_input, config_result in zip( scrapli_response.channel_input.split(\"\\n\"), scrapli_response.result.split(\"\\n\") ): if config_input == config_result: full_results += f\"{config_input}\\n\" else: full_results += \"\\n\".join([config_input, config_result]) else: for response in scrapli_response: full_results += \"\\n\".join([response.channel_input, response.result]) return full_results class ScrapliResult(Result): def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed( scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] ) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, (Response, ScrapliCfgResponse)): failed: bool = scrapli_response.failed return failed if any(response.failed for response in scrapli_response): return True return False Functions \u00b6 process_command_result \u00b6 process_command_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str 1 2 3 4 5 6 7 8 9 10 Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A process_config_result \u00b6 process_config_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str 1 2 3 4 5 6 7 8 9 10 Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A Classes \u00b6 ScrapliResult \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 Result of running individual tasks. Arguments: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead to this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Attributes: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead ot this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A Expand source code class ScrapliResult(Result): def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed( scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] ) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, (Response, ScrapliCfgResponse)): failed: bool = scrapli_response.failed return failed if any(response.failed for response in scrapli_response): return True return False Ancestors (in MRO) \u00b6 nornir.core.task.Result","title":"Result"},{"location":"api_docs/result/#module-nornir_scrapliresult","text":"nornir_scrapli.result Expand source code \"\"\"nornir_scrapli.result\"\"\" from typing import TYPE_CHECKING, Any, Optional, Union from scrapli.response import MultiResponse, Response from scrapli_cfg.response import ScrapliCfgResponse from nornir.core.task import Result if TYPE_CHECKING: from nornir.core.inventory import Host # pylint: disable=C0412 def process_command_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" if isinstance(scrapli_response, Response): result: str = scrapli_response.result return result return \"\\n\\n\".join([response.result for response in scrapli_response]) def process_config_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" full_results = \"\" if isinstance(scrapli_response, Response): for config_input, config_result in zip( scrapli_response.channel_input.split(\"\\n\"), scrapli_response.result.split(\"\\n\") ): if config_input == config_result: full_results += f\"{config_input}\\n\" else: full_results += \"\\n\".join([config_input, config_result]) else: for response in scrapli_response: full_results += \"\\n\".join([response.channel_input, response.result]) return full_results class ScrapliResult(Result): def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed( scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] ) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, (Response, ScrapliCfgResponse)): failed: bool = scrapli_response.failed return failed if any(response.failed for response in scrapli_response): return True return False","title":"Module nornir_scrapli.result"},{"location":"api_docs/result/#functions","text":"","title":"Functions"},{"location":"api_docs/result/#process_command_result","text":"process_command_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str 1 2 3 4 5 6 7 8 9 10 Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A","title":"process_command_result"},{"location":"api_docs/result/#process_config_result","text":"process_config_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str 1 2 3 4 5 6 7 8 9 10 Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A","title":"process_config_result"},{"location":"api_docs/result/#classes","text":"","title":"Classes"},{"location":"api_docs/result/#scrapliresult","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 Result of running individual tasks. Arguments: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead to this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Attributes: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead ot this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A Expand source code class ScrapliResult(Result): def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed( scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] ) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, (Response, ScrapliCfgResponse)): failed: bool = scrapli_response.failed return failed if any(response.failed for response in scrapli_response): return True return False","title":"ScrapliResult"},{"location":"api_docs/result/#ancestors-in-mro","text":"nornir.core.task.Result","title":"Ancestors (in MRO)"},{"location":"api_docs/tasks/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module nornir_scrapli.tasks \u00b6 nornir_scrapli.tasks Expand source code \"\"\"nornir_scrapli.tasks\"\"\" from nornir_scrapli.tasks.cfg.abort_config import cfg_abort_config from nornir_scrapli.tasks.cfg.commit_config import cfg_commit_config from nornir_scrapli.tasks.cfg.diff_config import cfg_diff_config from nornir_scrapli.tasks.cfg.get_config import cfg_get_config from nornir_scrapli.tasks.cfg.get_version import cfg_get_version from nornir_scrapli.tasks.cfg.load_config import cfg_load_config from nornir_scrapli.tasks.core.get_prompt import get_prompt from nornir_scrapli.tasks.core.send_command import send_command from nornir_scrapli.tasks.core.send_commands import send_commands from nornir_scrapli.tasks.core.send_commands_from_file import send_commands_from_file from nornir_scrapli.tasks.core.send_config import send_config from nornir_scrapli.tasks.core.send_configs import send_configs from nornir_scrapli.tasks.core.send_configs_from_file import send_configs_from_file from nornir_scrapli.tasks.core.send_interactive import send_interactive from nornir_scrapli.tasks.netconf.capabilities import netconf_capabilities from nornir_scrapli.tasks.netconf.commit import netconf_commit from nornir_scrapli.tasks.netconf.delete_config import netconf_delete_config from nornir_scrapli.tasks.netconf.discard import netconf_discard from nornir_scrapli.tasks.netconf.edit_config import netconf_edit_config from nornir_scrapli.tasks.netconf.get import netconf_get from nornir_scrapli.tasks.netconf.get_config import netconf_get_config from nornir_scrapli.tasks.netconf.lock import netconf_lock from nornir_scrapli.tasks.netconf.rpc import netconf_rpc from nornir_scrapli.tasks.netconf.unlock import netconf_unlock from nornir_scrapli.tasks.netconf.validate import netconf_validate __all__ = ( \"cfg_abort_config\", \"cfg_commit_config\", \"cfg_diff_config\", \"cfg_get_config\", \"cfg_get_version\", \"cfg_load_config\", \"get_prompt\", \"netconf_capabilities\", \"netconf_commit\", \"netconf_delete_config\", \"netconf_discard\", \"netconf_edit_config\", \"netconf_get\", \"netconf_get_config\", \"netconf_lock\", \"netconf_rpc\", \"netconf_unlock\", \"netconf_validate\", \"send_command\", \"send_commands\", \"send_commands_from_file\", \"send_config\", \"send_configs\", \"send_configs_from_file\", \"send_interactive\", ) Functions \u00b6 cfg_abort_config \u00b6 cfg_abort_config(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Abort a device candidate config with scrapli-cfg Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A cfg_commit_config \u00b6 cfg_commit_config(task: nornir.core.task.Task, source: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Commit a device candidate config with scrapli-cfg Args: task: nornir task object source: name of the config source to commit against, generally running|startup Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A cfg_diff_config \u00b6 cfg_diff_config(task: nornir.core.task.Task, source: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Diff a device candidate config vs a source config with scrapli-cfg The \"device diff\" is stored as the result. You can access the side by side or unified scrapli cfg diffs via the \"scrapli_response\" object stored in the result! Args: task: nornir task object source: name of the config source to commit against, generally running|startup Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A cfg_get_config \u00b6 cfg_get_config(task: nornir.core.task.Task, source: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Get device config with scrapli-cfg Args: task: nornir task object source: config source to get Returns: Result: nornir result object with Result.result value set to current prompt Raises: N/A cfg_get_version \u00b6 cfg_get_version(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 Get device version with scrapli-cfg Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to current version of device Raises: N/A cfg_load_config \u00b6 cfg_load_config(task: nornir.core.task.Task, config: str, replace: bool = False, **kwargs: Any) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Load device config with scrapli-cfg Note that `changed` will still be `False` because this is just loading a candidate config! Args: task: nornir task object config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A get_prompt \u00b6 get_prompt(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 Get current prompt from device using scrapli Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to current prompt Raises: N/A netconf_capabilities \u00b6 netconf_capabilities(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Retrieve the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to a list of strings representing the device capabilities Raises: N/A netconf_commit \u00b6 netconf_commit(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Commit the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_delete_config \u00b6 netconf_delete_config(task: nornir.core.task.Task, target: str = 'candidate') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Send a \"delete-config\" rcp to the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the delete operation Raises: N/A netconf_discard \u00b6 netconf_discard(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Discard the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_edit_config \u00b6 netconf_edit_config(task: nornir.core.task.Task, config: str, dry_run: Optional[bool] = None, diff: bool = False, target: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Edit config from the device with scrapli_netconf Args: task: nornir task object config: configuration to send to device dry_run: if True config will be pushed and then discarded; will discard anything already pushed that has *not* been committed already, so be careful! :D; also note that this will only work if there is a candidate datastore -- meaning that, for example, with IOSXE with a target of \"running\" there is no way to discard the configuration as it will already have been written to the running datastore diff: capture/set diff of target datastore xml text of before/after edit config operation target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A netconf_get \u00b6 netconf_get(task: nornir.core.task.Task, filter_: str, filter_type: str = 'subtree') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 Get from the device with scrapli_netconf Args: task: nornir task object filter_: string filter to apply to the get filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_get_config \u00b6 netconf_get_config(task: nornir.core.task.Task, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Get config from the device with scrapli_netconf Args: task: nornir task object source: configuration source to get; typically one of running|startup|candidate filters: string or list of strings of filters to apply to configuration filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A netconf_lock \u00b6 netconf_lock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Lock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_rpc \u00b6 netconf_rpc(task: nornir.core.task.Task, filter_: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Send a \"bare\" rcp to the device with scrapli_netconf Args: task: nornir task object filter_: filter/rpc to execute Returns: Result: nornir result object with Result.result value set the string result of the rpc operation Raises: N/A netconf_unlock \u00b6 netconf_unlock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Unlock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_validate \u00b6 netconf_validate(task: nornir.core.task.Task, source: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Send a \"validate\" rcp to the device with scrapli_netconf Args: task: nornir task object source: configuration source to validate; typically one of running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A send_command \u00b6 send_command(task: nornir.core.task.Task, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Send a single command to device using scrapli Args: task: nornir task object command: string to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: scrapli nornir result object; almost identical to a \"normal\" nornir result object, but contains an additional attribute \"scrapli_response\" that contains the original response from scrapli Raises: N/A send_commands \u00b6 send_commands(task: nornir.core.task.Task, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Send a list of commands to device using scrapli Args: task: nornir task object commands: list of strings to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A send_commands_from_file \u00b6 send_commands_from_file(task: nornir.core.task.Task, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Send a list of commands from a file to device using scrapli Args: task: nornir task object file: string path to file strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A send_config \u00b6 send_config(task: nornir.core.task.Task, config: str, dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Send a config to device using scrapli Args: task: nornir task object config: string configuration to send to the device, supports sending multi-line strings dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type send_configs \u00b6 send_configs(task: nornir.core.task.Task, configs: List[str], dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Send configs to device using scrapli Args: task: nornir task object configs: list of strings to send to device in config mode dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type send_configs_from_file \u00b6 send_configs_from_file(task: nornir.core.task.Task, file: str, dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Send configs from a file to device using scrapli Args: task: nornir task object file: string path to file dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type send_interactive \u00b6 send_interactive(task: nornir.core.task.Task, interact_events: List[Tuple[str, str, Optional[bool]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '', timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 Send inputs in an interactive fashion using scrapli; usually used to handle prompts Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input) An example where we need this sort of capability: 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password: Password: Sink: C0644 639 test1.txt ! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# 1 To accomplish this we can use the following (in \"native\" scrapli): interact = conn.channel.send_inputs_interact( [ (\"copy flash: scp:\", \"Source filename []?\", False), (\"test1.txt\", \"Address or name of remote host []?\", False), (\"172.31.254.100\", \"Destination username [carl]?\", False), (\"carl\", \"Password:\", False), (\"super_secure_password\", prompt, True), ] ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\". Args: task: nornir task object interact_events: list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden) failed_when_contains: list of strings that, if present in final output, represent a failed command/interaction privilege_level: name of the privilege level to operate in timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A","title":"Tasks"},{"location":"api_docs/tasks/#module-nornir_scraplitasks","text":"nornir_scrapli.tasks Expand source code \"\"\"nornir_scrapli.tasks\"\"\" from nornir_scrapli.tasks.cfg.abort_config import cfg_abort_config from nornir_scrapli.tasks.cfg.commit_config import cfg_commit_config from nornir_scrapli.tasks.cfg.diff_config import cfg_diff_config from nornir_scrapli.tasks.cfg.get_config import cfg_get_config from nornir_scrapli.tasks.cfg.get_version import cfg_get_version from nornir_scrapli.tasks.cfg.load_config import cfg_load_config from nornir_scrapli.tasks.core.get_prompt import get_prompt from nornir_scrapli.tasks.core.send_command import send_command from nornir_scrapli.tasks.core.send_commands import send_commands from nornir_scrapli.tasks.core.send_commands_from_file import send_commands_from_file from nornir_scrapli.tasks.core.send_config import send_config from nornir_scrapli.tasks.core.send_configs import send_configs from nornir_scrapli.tasks.core.send_configs_from_file import send_configs_from_file from nornir_scrapli.tasks.core.send_interactive import send_interactive from nornir_scrapli.tasks.netconf.capabilities import netconf_capabilities from nornir_scrapli.tasks.netconf.commit import netconf_commit from nornir_scrapli.tasks.netconf.delete_config import netconf_delete_config from nornir_scrapli.tasks.netconf.discard import netconf_discard from nornir_scrapli.tasks.netconf.edit_config import netconf_edit_config from nornir_scrapli.tasks.netconf.get import netconf_get from nornir_scrapli.tasks.netconf.get_config import netconf_get_config from nornir_scrapli.tasks.netconf.lock import netconf_lock from nornir_scrapli.tasks.netconf.rpc import netconf_rpc from nornir_scrapli.tasks.netconf.unlock import netconf_unlock from nornir_scrapli.tasks.netconf.validate import netconf_validate __all__ = ( \"cfg_abort_config\", \"cfg_commit_config\", \"cfg_diff_config\", \"cfg_get_config\", \"cfg_get_version\", \"cfg_load_config\", \"get_prompt\", \"netconf_capabilities\", \"netconf_commit\", \"netconf_delete_config\", \"netconf_discard\", \"netconf_edit_config\", \"netconf_get\", \"netconf_get_config\", \"netconf_lock\", \"netconf_rpc\", \"netconf_unlock\", \"netconf_validate\", \"send_command\", \"send_commands\", \"send_commands_from_file\", \"send_config\", \"send_configs\", \"send_configs_from_file\", \"send_interactive\", )","title":"Module nornir_scrapli.tasks"},{"location":"api_docs/tasks/#functions","text":"","title":"Functions"},{"location":"api_docs/tasks/#cfg_abort_config","text":"cfg_abort_config(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Abort a device candidate config with scrapli-cfg Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A","title":"cfg_abort_config"},{"location":"api_docs/tasks/#cfg_commit_config","text":"cfg_commit_config(task: nornir.core.task.Task, source: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Commit a device candidate config with scrapli-cfg Args: task: nornir task object source: name of the config source to commit against, generally running|startup Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A","title":"cfg_commit_config"},{"location":"api_docs/tasks/#cfg_diff_config","text":"cfg_diff_config(task: nornir.core.task.Task, source: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Diff a device candidate config vs a source config with scrapli-cfg The \"device diff\" is stored as the result. You can access the side by side or unified scrapli cfg diffs via the \"scrapli_response\" object stored in the result! Args: task: nornir task object source: name of the config source to commit against, generally running|startup Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A","title":"cfg_diff_config"},{"location":"api_docs/tasks/#cfg_get_config","text":"cfg_get_config(task: nornir.core.task.Task, source: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Get device config with scrapli-cfg Args: task: nornir task object source: config source to get Returns: Result: nornir result object with Result.result value set to current prompt Raises: N/A","title":"cfg_get_config"},{"location":"api_docs/tasks/#cfg_get_version","text":"cfg_get_version(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 Get device version with scrapli-cfg Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to current version of device Raises: N/A","title":"cfg_get_version"},{"location":"api_docs/tasks/#cfg_load_config","text":"cfg_load_config(task: nornir.core.task.Task, config: str, replace: bool = False, **kwargs: Any) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Load device config with scrapli-cfg Note that `changed` will still be `False` because this is just loading a candidate config! Args: task: nornir task object config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: Result: nornir result object with Result.result value set the string result of the load_config operation Raises: N/A","title":"cfg_load_config"},{"location":"api_docs/tasks/#get_prompt","text":"get_prompt(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 Get current prompt from device using scrapli Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to current prompt Raises: N/A","title":"get_prompt"},{"location":"api_docs/tasks/#netconf_capabilities","text":"netconf_capabilities(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Retrieve the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to a list of strings representing the device capabilities Raises: N/A","title":"netconf_capabilities"},{"location":"api_docs/tasks/#netconf_commit","text":"netconf_commit(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Commit the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_commit"},{"location":"api_docs/tasks/#netconf_delete_config","text":"netconf_delete_config(task: nornir.core.task.Task, target: str = 'candidate') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Send a \"delete-config\" rcp to the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the delete operation Raises: N/A","title":"netconf_delete_config"},{"location":"api_docs/tasks/#netconf_discard","text":"netconf_discard(task: nornir.core.task.Task) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 Discard the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_discard"},{"location":"api_docs/tasks/#netconf_edit_config","text":"netconf_edit_config(task: nornir.core.task.Task, config: str, dry_run: Optional[bool] = None, diff: bool = False, target: str = 'running') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Edit config from the device with scrapli_netconf Args: task: nornir task object config: configuration to send to device dry_run: if True config will be pushed and then discarded; will discard anything already pushed that has *not* been committed already, so be careful! :D; also note that this will only work if there is a candidate datastore -- meaning that, for example, with IOSXE with a target of \"running\" there is no way to discard the configuration as it will already have been written to the running datastore diff: capture/set diff of target datastore xml text of before/after edit config operation target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A","title":"netconf_edit_config"},{"location":"api_docs/tasks/#netconf_get","text":"netconf_get(task: nornir.core.task.Task, filter_: str, filter_type: str = 'subtree') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 Get from the device with scrapli_netconf Args: task: nornir task object filter_: string filter to apply to the get filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_get"},{"location":"api_docs/tasks/#netconf_get_config","text":"netconf_get_config(task: nornir.core.task.Task, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Get config from the device with scrapli_netconf Args: task: nornir task object source: configuration source to get; typically one of running|startup|candidate filters: string or list of strings of filters to apply to configuration filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A","title":"netconf_get_config"},{"location":"api_docs/tasks/#netconf_lock","text":"netconf_lock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Lock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_lock"},{"location":"api_docs/tasks/#netconf_rpc","text":"netconf_rpc(task: nornir.core.task.Task, filter_: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Send a \"bare\" rcp to the device with scrapli_netconf Args: task: nornir task object filter_: filter/rpc to execute Returns: Result: nornir result object with Result.result value set the string result of the rpc operation Raises: N/A","title":"netconf_rpc"},{"location":"api_docs/tasks/#netconf_unlock","text":"netconf_unlock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Unlock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_unlock"},{"location":"api_docs/tasks/#netconf_validate","text":"netconf_validate(task: nornir.core.task.Task, source: str) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 Send a \"validate\" rcp to the device with scrapli_netconf Args: task: nornir task object source: configuration source to validate; typically one of running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_validate"},{"location":"api_docs/tasks/#send_command","text":"send_command(task: nornir.core.task.Task, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Send a single command to device using scrapli Args: task: nornir task object command: string to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: scrapli nornir result object; almost identical to a \"normal\" nornir result object, but contains an additional attribute \"scrapli_response\" that contains the original response from scrapli Raises: N/A","title":"send_command"},{"location":"api_docs/tasks/#send_commands","text":"send_commands(task: nornir.core.task.Task, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Send a list of commands to device using scrapli Args: task: nornir task object commands: list of strings to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A","title":"send_commands"},{"location":"api_docs/tasks/#send_commands_from_file","text":"send_commands_from_file(task: nornir.core.task.Task, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Send a list of commands from a file to device using scrapli Args: task: nornir task object file: string path to file strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A","title":"send_commands_from_file"},{"location":"api_docs/tasks/#send_config","text":"send_config(task: nornir.core.task.Task, config: str, dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Send a config to device using scrapli Args: task: nornir task object config: string configuration to send to the device, supports sending multi-line strings dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type","title":"send_config"},{"location":"api_docs/tasks/#send_configs","text":"send_configs(task: nornir.core.task.Task, configs: List[str], dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Send configs to device using scrapli Args: task: nornir task object configs: list of strings to send to device in config mode dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type","title":"send_configs"},{"location":"api_docs/tasks/#send_configs_from_file","text":"send_configs_from_file(task: nornir.core.task.Task, file: str, dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Send configs from a file to device using scrapli Args: task: nornir task object file: string path to file dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type","title":"send_configs_from_file"},{"location":"api_docs/tasks/#send_interactive","text":"send_interactive(task: nornir.core.task.Task, interact_events: List[Tuple[str, str, Optional[bool]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '', timeout_ops: Optional[float] = None) \u2011> nornir.core.task.Result 1 2 3 4 5 6 7 8 9 10 Send inputs in an interactive fashion using scrapli; usually used to handle prompts Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input) An example where we need this sort of capability: 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password: Password: Sink: C0644 639 test1.txt ! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# 1 To accomplish this we can use the following (in \"native\" scrapli): interact = conn.channel.send_inputs_interact( [ (\"copy flash: scp:\", \"Source filename []?\", False), (\"test1.txt\", \"Address or name of remote host []?\", False), (\"172.31.254.100\", \"Destination username [carl]?\", False), (\"carl\", \"Password:\", False), (\"super_secure_password\", prompt, True), ] ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\". Args: task: nornir task object interact_events: list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden) failed_when_contains: list of strings that, if present in final output, represent a failed command/interaction privilege_level: name of the privilege level to operate in timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A","title":"send_interactive"},{"location":"more_scrapli/scrapli/","text":"Scrapli \u00b6 scrapli ( docs ) is the \"parent\" scrapli library. Check it out if you need to connect to devices with telnet or ssh!","title":"Scrapli"},{"location":"more_scrapli/scrapli/#scrapli","text":"scrapli ( docs ) is the \"parent\" scrapli library. Check it out if you need to connect to devices with telnet or ssh!","title":"Scrapli"},{"location":"more_scrapli/scrapli_cfg/","text":"Scrapli Cfg \u00b6 scrapli_cfg ( docs ) is utility that accepts a scrapli Telnet or SSH connection and provides configuration management capabilities. scrapli_cfg allows you to load candidate configurations for merge or replace operations, generate diffs of the current vs candidate, and of course commit or abort the candidate configuration.","title":"Scrapli Cfg"},{"location":"more_scrapli/scrapli_cfg/#scrapli-cfg","text":"scrapli_cfg ( docs ) is utility that accepts a scrapli Telnet or SSH connection and provides configuration management capabilities. scrapli_cfg allows you to load candidate configurations for merge or replace operations, generate diffs of the current vs candidate, and of course commit or abort the candidate configuration.","title":"Scrapli Cfg"},{"location":"more_scrapli/scrapli_community/","text":"Scrapli Community \u00b6 If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_community/#scrapli-community","text":"If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_netconf/","text":"Scrapli Netconf \u00b6 scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_netconf/#scrapli-netconf","text":"scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_replay/","text":"Scrapli Replay \u00b6 scrapli_replay ( docs ) is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that patches and records and replays session data (like vcr.py ) for scrapli connections.","title":"Scrapli Replay"},{"location":"more_scrapli/scrapli_replay/#scrapli-replay","text":"scrapli_replay ( docs ) is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that patches and records and replays session data (like vcr.py ) for scrapli connections.","title":"Scrapli Replay"},{"location":"user_guide/available_functions/","text":"Available Functions \u00b6 print_structured_result -- this function is very similar to the \"normal\" print_result function that now ships with the nornir_utils library (historically with nornir \"core\"), except it contains several additional arguments, most importantly the parser argument allows you to select textfsm or genie to decide which parser to use to parse the unstructured data stored in the results object. Please see the structured results example here for more details.","title":"Available Functions"},{"location":"user_guide/available_functions/#available-functions","text":"print_structured_result -- this function is very similar to the \"normal\" print_result function that now ships with the nornir_utils library (historically with nornir \"core\"), except it contains several additional arguments, most importantly the parser argument allows you to select textfsm or genie to decide which parser to use to parse the unstructured data stored in the results object. Please see the structured results example here for more details.","title":"Available Functions"},{"location":"user_guide/available_tasks/","text":"Available Tasks \u00b6 All tasks presented here are methods that live in scrapli or scrapli_netconf -- these tasks are simply \"wrapped \" in such a way that they may be used within the constructs of nornir ! The links below link back to the scrapli or scrapli_netconf docs for the given method -- in all (or very nearly all?) cases, the same arguments that the underlying library supports will be exposed to nornir ! Scrapli \"core\" Tasks \u00b6 get_prompt - Get the current prompt of the device send_command - Send a single command to the device send_commands - Send a list of commands to the device send_commands_from_file - Send a list of commands from a file to the device send_config - Send a configuration to the device send_configs - Send a list of configurations to the device send_configs_from_file - Send a list of configurations from a file to the device send_interactive -\"Interact\" with the device (handle prompts and inputs and things like that) Scrapli Netconf Tasks \u00b6 Note that not all devices will support all operations! netconf_capabilities - Get list of capabilities as exchanged during netconf connection establishment netconf_commit - Commit the configuration on the device netconf_discard - Discard the configuration on the device netconf_edit_config - Edit the configuration on the device netconf_delete_config - Delete a given datastore on the device netconf_get - Get a subtree or xpath from the device netconf_get_config - Get the configuration from the device netconf_lock - Lock the datastore on the device netconf_unlock - Unlock the datastore on the device netconf_rpc - Send a \"bare\" RPC to the device netconf_validate - Execute the validate rpc against a given datastore Scrapli Cfg Tasks \u00b6 cfg_abort_config - Abort a loaded candidate config cfg_commit_config - Commit a loaded candidate config cfg_diff_config - Diff a loaded candidate config cfg_get_config - Get a target config cfg_get_version - Get the device version string cfg_load_config - Load a candidate config","title":"Available Tasks"},{"location":"user_guide/available_tasks/#available-tasks","text":"All tasks presented here are methods that live in scrapli or scrapli_netconf -- these tasks are simply \"wrapped \" in such a way that they may be used within the constructs of nornir ! The links below link back to the scrapli or scrapli_netconf docs for the given method -- in all (or very nearly all?) cases, the same arguments that the underlying library supports will be exposed to nornir !","title":"Available Tasks"},{"location":"user_guide/available_tasks/#scrapli-core-tasks","text":"get_prompt - Get the current prompt of the device send_command - Send a single command to the device send_commands - Send a list of commands to the device send_commands_from_file - Send a list of commands from a file to the device send_config - Send a configuration to the device send_configs - Send a list of configurations to the device send_configs_from_file - Send a list of configurations from a file to the device send_interactive -\"Interact\" with the device (handle prompts and inputs and things like that)","title":"Scrapli \"core\" Tasks"},{"location":"user_guide/available_tasks/#scrapli-netconf-tasks","text":"Note that not all devices will support all operations! netconf_capabilities - Get list of capabilities as exchanged during netconf connection establishment netconf_commit - Commit the configuration on the device netconf_discard - Discard the configuration on the device netconf_edit_config - Edit the configuration on the device netconf_delete_config - Delete a given datastore on the device netconf_get - Get a subtree or xpath from the device netconf_get_config - Get the configuration from the device netconf_lock - Lock the datastore on the device netconf_unlock - Unlock the datastore on the device netconf_rpc - Send a \"bare\" RPC to the device netconf_validate - Execute the validate rpc against a given datastore","title":"Scrapli Netconf Tasks"},{"location":"user_guide/available_tasks/#scrapli-cfg-tasks","text":"cfg_abort_config - Abort a loaded candidate config cfg_commit_config - Commit a loaded candidate config cfg_diff_config - Diff a loaded candidate config cfg_get_config - Get a target config cfg_get_version - Get the device version string cfg_load_config - Load a candidate config","title":"Scrapli Cfg Tasks"},{"location":"user_guide/basic_usage/","text":"Basic Usage \u00b6 Basic Information/Usage \u00b6 Nornir has historically contained it's plugins within the actual Nornir codebase itself, this however has changed! As of mid September 2020, Nornir 3.0.0 has been officially released -- this move to the 3.x.x version now expects plugins to be external to the code base. If you are looking for pre 3.x.x support, please use the 2020.09.01 version. If you have used Nornir before (pre 3.x.x), this package should be very similar to what you already know. Since the plugins used to live in Nornir you could simply import them from the appropriate package as such: 1 from nornir.plugins.tasks.networking import netconf_get_config With nornir_scrapli you simply install this package along side \"regular\" Nornir, and import the tasks from nornir_scrapli directly: 1 from nornir_scrapli.tasks import send_command As soon as a nornir_scrapli task is imported, it ( nornir_scrapli ) will register as a connection, and things should work as normal from there! The last important difference with nornir_scrapli is that in addition to the \"normal\" data in the Nornir Result object, nornir_scrapli also assigns the scrapli Response object (or list of Response objects) to the scrapli_response attribute. This means that you can access all of the \"normal\" scrapli response data from this object -- including things like elapsed_time and textfsm_parse_output : 1 2 3 4 >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . elapsed_time 0.039469 >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . textfsm_parse_output () [[ some structured data back from the device ! ]] If you would like to continue using print_result like \"normal\" in nornir, but would like to see structured data (if available) in the print_result output, you can use the nornir_scrapli print_structured_result function. This function can be imported from the scrapli functions module: 1 from nornir_scrapli.functions import print_structured_result This function acts pretty much exactly like the \"normal\" print result function, but will of course try to print the structured result. By default this will try to use textfsm to parse results, but it is of course configurable via the parser keyword argument. As scrapli will return an empty data structure if parsing fails, this may cause tasks to look like they are getting skipped in the output (nornir's print result function does not print empty lists), if you would like to fall back to printing the unparsed output you can do so by setting the fail_to_string keyword argument to True as follows: 1 print_structured_result ( my_agg_result , parser = \"genie\" , fail_to_string = True ) Using Different Transports \u00b6 nornir_scrapli supports all synchronous scrapli transport plugins. By default, the \"system\" transport will be used, however you can change this in the extras section of your nornir inventory: 1 2 3 4 5 6 7 connection_options : scrapli : port : 22 extras : ssh_config_file : True auth_strict_key : False transport : ssh2 Note that you will need to install scrapli_ssh2 or scrapli_paramiko if you want to use those transport plugins!","title":"Basic Usage"},{"location":"user_guide/basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"user_guide/basic_usage/#basic-informationusage","text":"Nornir has historically contained it's plugins within the actual Nornir codebase itself, this however has changed! As of mid September 2020, Nornir 3.0.0 has been officially released -- this move to the 3.x.x version now expects plugins to be external to the code base. If you are looking for pre 3.x.x support, please use the 2020.09.01 version. If you have used Nornir before (pre 3.x.x), this package should be very similar to what you already know. Since the plugins used to live in Nornir you could simply import them from the appropriate package as such: 1 from nornir.plugins.tasks.networking import netconf_get_config With nornir_scrapli you simply install this package along side \"regular\" Nornir, and import the tasks from nornir_scrapli directly: 1 from nornir_scrapli.tasks import send_command As soon as a nornir_scrapli task is imported, it ( nornir_scrapli ) will register as a connection, and things should work as normal from there! The last important difference with nornir_scrapli is that in addition to the \"normal\" data in the Nornir Result object, nornir_scrapli also assigns the scrapli Response object (or list of Response objects) to the scrapli_response attribute. This means that you can access all of the \"normal\" scrapli response data from this object -- including things like elapsed_time and textfsm_parse_output : 1 2 3 4 >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . elapsed_time 0.039469 >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . textfsm_parse_output () [[ some structured data back from the device ! ]] If you would like to continue using print_result like \"normal\" in nornir, but would like to see structured data (if available) in the print_result output, you can use the nornir_scrapli print_structured_result function. This function can be imported from the scrapli functions module: 1 from nornir_scrapli.functions import print_structured_result This function acts pretty much exactly like the \"normal\" print result function, but will of course try to print the structured result. By default this will try to use textfsm to parse results, but it is of course configurable via the parser keyword argument. As scrapli will return an empty data structure if parsing fails, this may cause tasks to look like they are getting skipped in the output (nornir's print result function does not print empty lists), if you would like to fall back to printing the unparsed output you can do so by setting the fail_to_string keyword argument to True as follows: 1 print_structured_result ( my_agg_result , parser = \"genie\" , fail_to_string = True )","title":"Basic Information/Usage"},{"location":"user_guide/basic_usage/#using-different-transports","text":"nornir_scrapli supports all synchronous scrapli transport plugins. By default, the \"system\" transport will be used, however you can change this in the extras section of your nornir inventory: 1 2 3 4 5 6 7 connection_options : scrapli : port : 22 extras : ssh_config_file : True auth_strict_key : False transport : ssh2 Note that you will need to install scrapli_ssh2 or scrapli_paramiko if you want to use those transport plugins!","title":"Using Different Transports"},{"location":"user_guide/installation/","text":"Installation \u00b6 Standard Installation \u00b6 As outlined in the quick start, you should be able to pip install scrapli \"normally\": 1 pip install nornir-scrapli Installing current master branch \u00b6 To install from the source repositories master branch: 1 pip install git+https://github.com/scrapli/nornir_scrapli Installing current develop branch \u00b6 To install from this repositories develop branch: 1 pip install -e git+https://github.com/scrapli/nornir_scrapli.git@develop#egg=nornir_scrapli Installation from Source \u00b6 To install from source: 1 2 3 git clone https://github.com/scrapli/nornir_scrapli cd nornir_scrapli python setup.py install Supported Platforms \u00b6 As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Installation"},{"location":"user_guide/installation/#installation","text":"","title":"Installation"},{"location":"user_guide/installation/#standard-installation","text":"As outlined in the quick start, you should be able to pip install scrapli \"normally\": 1 pip install nornir-scrapli","title":"Standard Installation"},{"location":"user_guide/installation/#installing-current-master-branch","text":"To install from the source repositories master branch: 1 pip install git+https://github.com/scrapli/nornir_scrapli","title":"Installing current master branch"},{"location":"user_guide/installation/#installing-current-develop-branch","text":"To install from this repositories develop branch: 1 pip install -e git+https://github.com/scrapli/nornir_scrapli.git@develop#egg=nornir_scrapli","title":"Installing current develop branch"},{"location":"user_guide/installation/#installation-from-source","text":"To install from source: 1 2 3 git clone https://github.com/scrapli/nornir_scrapli cd nornir_scrapli python setup.py install","title":"Installation from Source"},{"location":"user_guide/installation/#supported-platforms","text":"As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Supported Platforms"},{"location":"user_guide/project_details/","text":"Project Details \u00b6 What is nornir_scrapli \u00b6 nornir_scrapli is scrapli (and scrapli netconf's) plugin for Nornir. Nearly all (synchronous) methods of scrapli are available/exposed in nornir scrapli. So if you enjoy scrapli, but also want the built-in concurrency and inventory management afforded by nornir, this is the place to be! Supported Platforms \u00b6 nornir_scrapli supports the \"core\" scrapli drivers, the GenericDriver (for use with linux hosts generally speaking ), and the scrapli_community platforms as well! See scrapli core docs and the scrapli community docs for more info. The platform argument in the inventory data should use the \"normal\" NAPALM style platform names, generic , or the name of the scrapli_community platform (i.e. huawei_vrp )). Example platform values (for inventory data): 1 2 3 4 5 6 7 platform: cisco_iosxe platform: cisco_iosxr platform: cisco_nxos platform: arista_eos platform: juniper_junos platform: generic platform: huawei_vrp Related Scrapli Libraries \u00b6 This repo is the nornir plugin for scrapli, however there are other libraries/repos in the scrapli family -- here is a list/link to all of the other scrapli things! scrapli scrapli_netconf scrapli_community scrapli_cfg scrapli_replay","title":"Project Details"},{"location":"user_guide/project_details/#project-details","text":"","title":"Project Details"},{"location":"user_guide/project_details/#what-is-nornir_scrapli","text":"nornir_scrapli is scrapli (and scrapli netconf's) plugin for Nornir. Nearly all (synchronous) methods of scrapli are available/exposed in nornir scrapli. So if you enjoy scrapli, but also want the built-in concurrency and inventory management afforded by nornir, this is the place to be!","title":"What is nornir_scrapli"},{"location":"user_guide/project_details/#supported-platforms","text":"nornir_scrapli supports the \"core\" scrapli drivers, the GenericDriver (for use with linux hosts generally speaking ), and the scrapli_community platforms as well! See scrapli core docs and the scrapli community docs for more info. The platform argument in the inventory data should use the \"normal\" NAPALM style platform names, generic , or the name of the scrapli_community platform (i.e. huawei_vrp )). Example platform values (for inventory data): 1 2 3 4 5 6 7 platform: cisco_iosxe platform: cisco_iosxr platform: cisco_nxos platform: arista_eos platform: juniper_junos platform: generic platform: huawei_vrp","title":"Supported Platforms"},{"location":"user_guide/project_details/#related-scrapli-libraries","text":"This repo is the nornir plugin for scrapli, however there are other libraries/repos in the scrapli family -- here is a list/link to all of the other scrapli things! scrapli scrapli_netconf scrapli_community scrapli_cfg scrapli_replay","title":"Related Scrapli Libraries"},{"location":"user_guide/quickstart/","text":"Quick Start Guide \u00b6 Installation \u00b6 In most cases installation via pip is the simplest and best way to install nornir_scrapli. 1 pip install nornir-scrapli A Simple Example \u00b6 Example config file: 1 2 3 4 5 6 7 --- inventory : plugin : YAMLInventory options : host_file : \"nornir_data/hosts.yaml\" group_file : \"nornir_data/groups.yaml\" defaults_file : \"nornir_data/defaults.yaml\" Example inventory file (host/group/default, see \"real\" Nornir docs for lots more info!) -- please notice that there is a scrapli and a scrapli_netconf connection type here!: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- iosxe-1 : hostname : 172.18.0.11 connection_options : scrapli : platform : cisco_iosxe port : 22 extras : ssh_config_file : True auth_strict_key : False scrapli_netconf : port : 830 extras : ssh_config_file : True auth_strict_key : False NOTE: scrapli-netconf has no concept (at the moment!) of \"platforms\" - it simply implements RFC compliant NETCONF RPCs, so you do not need to pass iosxr , junos or anything like that to the scrapli_netconf connection options section! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from nornir import InitNornir from nornir_scrapli.tasks import ( get_prompt , send_command , send_configs ) nr = InitNornir ( config_file = \"nornir_data/config.yaml\" ) prompt_results = nr . run ( task = get_prompt ) command_results = nr . run ( task = send_command , command = \"show version\" ) config_results = nr . run ( task = send_configs , configs = [ \"interface loopback123\" , \"description nornir_scrapli was here\" ], ) print ( \"get_prompt result:\" ) print ( prompt_results [ \"iosxe-1\" ] . result ) print ( \"send_command result:\" ) print ( command_results [ \"iosxe-1\" ] . result ) print ( \"send_configs result:\" ) print ( config_results [ \"iosxe-1\" ] . result ) 1 2 3 4 5 6 7 $ python my_scrapli_script.py get_prompt result: 3560CX# send_command result: Cisco IOS Software, C3560CX Software (C3560CX-UNIVERSALK9-M), Version 15.2(4)E7, RELEASE SOFTWARE (fc2) <SNIP> send_configs result: Netconf tasks are imported from the same package and in the same fashion as the \"core\" scrapli tasks: 1 2 3 4 5 6 7 8 from nornir_scrapli.tasks import ( netconf_lock , netconf_unlock , netconf_edit_config , netconf_get , netconf_get_config , netconf_rpc ) And are executed in the same fashion as well: 1 2 3 4 5 6 7 8 9 10 11 config = \"\"\"<config> <interfaces xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\"> <interface> <name>GigabitEthernet1</name> <description>scrapli was here!</description> </interface> </interfaces> </config>\"\"\" result = nr . run ( task = netconf_edit_config , config = config ) print ( result [ 'iosxe1' ][ 0 ] . result ) print ( result [ 'iosxe1' ][ 0 ] . scrapli_response . xml_result ) When using the scrapli-netconf tasks the result object result will be the string of the returned data from the device. As with all other nornir-scrapli results, the scrapli_response object will be assigned to the Result object and will contain all of the \"normal\" scrapli response object data (or scrapli-netconf response data ), such as the elapsed_time , raw_result , xml_result , etc. -- you can see this in the above example! Additional Examples \u00b6 NETCONF Usage Structured Data","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#installation","text":"In most cases installation via pip is the simplest and best way to install nornir_scrapli. 1 pip install nornir-scrapli","title":"Installation"},{"location":"user_guide/quickstart/#a-simple-example","text":"Example config file: 1 2 3 4 5 6 7 --- inventory : plugin : YAMLInventory options : host_file : \"nornir_data/hosts.yaml\" group_file : \"nornir_data/groups.yaml\" defaults_file : \"nornir_data/defaults.yaml\" Example inventory file (host/group/default, see \"real\" Nornir docs for lots more info!) -- please notice that there is a scrapli and a scrapli_netconf connection type here!: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- iosxe-1 : hostname : 172.18.0.11 connection_options : scrapli : platform : cisco_iosxe port : 22 extras : ssh_config_file : True auth_strict_key : False scrapli_netconf : port : 830 extras : ssh_config_file : True auth_strict_key : False NOTE: scrapli-netconf has no concept (at the moment!) of \"platforms\" - it simply implements RFC compliant NETCONF RPCs, so you do not need to pass iosxr , junos or anything like that to the scrapli_netconf connection options section! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from nornir import InitNornir from nornir_scrapli.tasks import ( get_prompt , send_command , send_configs ) nr = InitNornir ( config_file = \"nornir_data/config.yaml\" ) prompt_results = nr . run ( task = get_prompt ) command_results = nr . run ( task = send_command , command = \"show version\" ) config_results = nr . run ( task = send_configs , configs = [ \"interface loopback123\" , \"description nornir_scrapli was here\" ], ) print ( \"get_prompt result:\" ) print ( prompt_results [ \"iosxe-1\" ] . result ) print ( \"send_command result:\" ) print ( command_results [ \"iosxe-1\" ] . result ) print ( \"send_configs result:\" ) print ( config_results [ \"iosxe-1\" ] . result ) 1 2 3 4 5 6 7 $ python my_scrapli_script.py get_prompt result: 3560CX# send_command result: Cisco IOS Software, C3560CX Software (C3560CX-UNIVERSALK9-M), Version 15.2(4)E7, RELEASE SOFTWARE (fc2) <SNIP> send_configs result: Netconf tasks are imported from the same package and in the same fashion as the \"core\" scrapli tasks: 1 2 3 4 5 6 7 8 from nornir_scrapli.tasks import ( netconf_lock , netconf_unlock , netconf_edit_config , netconf_get , netconf_get_config , netconf_rpc ) And are executed in the same fashion as well: 1 2 3 4 5 6 7 8 9 10 11 config = \"\"\"<config> <interfaces xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\"> <interface> <name>GigabitEthernet1</name> <description>scrapli was here!</description> </interface> </interfaces> </config>\"\"\" result = nr . run ( task = netconf_edit_config , config = config ) print ( result [ 'iosxe1' ][ 0 ] . result ) print ( result [ 'iosxe1' ][ 0 ] . scrapli_response . xml_result ) When using the scrapli-netconf tasks the result object result will be the string of the returned data from the device. As with all other nornir-scrapli results, the scrapli_response object will be assigned to the Result object and will contain all of the \"normal\" scrapli response object data (or scrapli-netconf response data ), such as the elapsed_time , raw_result , xml_result , etc. -- you can see this in the above example!","title":"A Simple Example"},{"location":"user_guide/quickstart/#additional-examples","text":"NETCONF Usage Structured Data","title":"Additional Examples"},{"location":"user_guide/versioning/","text":"Versioning \u00b6 Please see the scrapli \"core\" here documentation for versioning information.","title":"Versioning"},{"location":"user_guide/versioning/#versioning","text":"Please see the scrapli \"core\" here documentation for versioning information.","title":"Versioning"}]}