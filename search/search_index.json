{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nornir_scrapli \u00b6 nornir_scrapli -- scrapli 's and scrapli_netconf 's plugin for nornir!","title":"Scrapli Nornir"},{"location":"#nornir_scrapli","text":"nornir_scrapli -- scrapli 's and scrapli_netconf 's plugin for nornir!","title":"nornir_scrapli"},{"location":"about/code_of_conduct/","text":"Code of Conduct \u00b6 Be excellent to each other!","title":"Code of Conduct"},{"location":"about/code_of_conduct/#code-of-conduct","text":"Be excellent to each other!","title":"Code of Conduct"},{"location":"about/contributing/","text":"Contributing \u00b6 Thanks for thinking about contributing to nornir_scrapli! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open an issue to discuss any bug fixes, feature adds, or really any thing that could result in a pull request. This allows us to all be on the same page, and could save everyone some extra work! Once we've discussed any changes, pull requests are of course welcome and very much appreciated! All PRs should pass tests -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"about/contributing/#contributing","text":"Thanks for thinking about contributing to nornir_scrapli! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open an issue to discuss any bug fixes, feature adds, or really any thing that could result in a pull request. This allows us to all be on the same page, and could save everyone some extra work! Once we've discussed any changes, pull requests are of course welcome and very much appreciated! All PRs should pass tests -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"api_docs/connection/","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting()) Module nornir_scrapli.connection \u00b6 nornir_scrapli.connection Expand source code \"\"\"nornir_scrapli.connection\"\"\" from typing import Any, Dict, Optional from scrapli import Scrapli from scrapli.driver import GenericDriver from scrapli.exceptions import ScrapliModuleNotFound from scrapli_netconf.driver import NetconfDriver from nornir.core.configuration import Config from nornir_scrapli.exceptions import NornirScrapliInvalidPlatform CONNECTION_NAME = \"scrapli\" PLATFORM_MAP = { \"ios\": \"cisco_iosxe\", \"nxos\": \"cisco_nxos\", \"iosxr\": \"cisco_iosxr\", \"eos\": \"arista_eos\", \"junos\": \"juniper_junos\", } class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"No `platform` provided in inventory for host `{hostname}`\" ) if platform in PLATFORM_MAP: platform = PLATFORM_MAP.get(platform) if platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=platform) # type: ignore except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{platform}` is not a valid scrapli or napalm platform, \" \"or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close() class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close() Classes \u00b6 ScrapliCore \u00b6 Scrapli connection plugin for nornir Expand source code class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"No `platform` provided in inventory for host `{hostname}`\" ) if platform in PLATFORM_MAP: platform = PLATFORM_MAP.get(platform) if platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=platform) # type: ignore except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{platform}` is not a valid scrapli or napalm platform, \" \"or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close() Methods \u00b6 close \u00b6 close(self) \u2011> NoneType Close a scrapli connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A open \u00b6 open(self, hostname: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType], port: Union[int, NoneType], platform: Union[str, NoneType], extras: Union[Dict[str, Any], NoneType] = None, configuration: Union[nornir.core.configuration.Config, NoneType] = None) \u2011> NoneType Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided ScrapliNetconf \u00b6 Scrapli NETCONF connection plugin for nornir Expand source code class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close() Methods \u00b6 close \u00b6 close(self) \u2011> NoneType Close a scrapli netconf connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A open \u00b6 open(self, hostname: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType], port: Union[int, NoneType], platform: Union[str, NoneType], extras: Union[Dict[str, Any], NoneType] = None, configuration: Union[nornir.core.configuration.Config, NoneType] = None) \u2011> NoneType Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: N/A","title":"Connection"},{"location":"api_docs/connection/#module-nornir_scrapliconnection","text":"nornir_scrapli.connection Expand source code \"\"\"nornir_scrapli.connection\"\"\" from typing import Any, Dict, Optional from scrapli import Scrapli from scrapli.driver import GenericDriver from scrapli.exceptions import ScrapliModuleNotFound from scrapli_netconf.driver import NetconfDriver from nornir.core.configuration import Config from nornir_scrapli.exceptions import NornirScrapliInvalidPlatform CONNECTION_NAME = \"scrapli\" PLATFORM_MAP = { \"ios\": \"cisco_iosxe\", \"nxos\": \"cisco_nxos\", \"iosxr\": \"cisco_iosxr\", \"eos\": \"arista_eos\", \"junos\": \"juniper_junos\", } class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"No `platform` provided in inventory for host `{hostname}`\" ) if platform in PLATFORM_MAP: platform = PLATFORM_MAP.get(platform) if platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=platform) # type: ignore except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{platform}` is not a valid scrapli or napalm platform, \" \"or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close() class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close()","title":"Module nornir_scrapli.connection"},{"location":"api_docs/connection/#classes","text":"","title":"Classes"},{"location":"api_docs/connection/#scraplicore","text":"Scrapli connection plugin for nornir Expand source code class ScrapliCore: \"\"\"Scrapli connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided \"\"\" extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 22, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) if not platform: raise NornirScrapliInvalidPlatform( f\"No `platform` provided in inventory for host `{hostname}`\" ) if platform in PLATFORM_MAP: platform = PLATFORM_MAP.get(platform) if platform == \"generic\": connection = GenericDriver(**parameters) else: try: connection = Scrapli(**parameters, platform=platform) # type: ignore except ScrapliModuleNotFound as exc: raise NornirScrapliInvalidPlatform( f\"Provided platform `{platform}` is not a valid scrapli or napalm platform, \" \"or is not a valid scrapli-community platform.\" ) from exc connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close()","title":"ScrapliCore"},{"location":"api_docs/connection/#methods","text":"","title":"Methods"},{"location":"api_docs/connection/#close","text":"close(self) \u2011> NoneType Close a scrapli connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A","title":"close"},{"location":"api_docs/connection/#open","text":"open(self, hostname: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType], port: Union[int, NoneType], platform: Union[str, NoneType], extras: Union[Dict[str, Any], NoneType] = None, configuration: Union[nornir.core.configuration.Config, NoneType] = None) \u2011> NoneType Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform string is provided","title":"open"},{"location":"api_docs/connection/#scraplinetconf","text":"Scrapli NETCONF connection plugin for nornir Expand source code class ScrapliNetconf: \"\"\"Scrapli NETCONF connection plugin for nornir\"\"\" def open( self, hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None, ) -> None: \"\"\" Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" # platform is irrelevant for scrapli netconf for now _ = platform extras = extras or {} # 99.9% configuration will always be passed here... but to be consistent w/ the other # plugins we'll leave the function signature same/same as the others global_config = configuration.dict() if configuration else {} parameters: Dict[str, Any] = { \"host\": hostname, \"auth_username\": username or \"\", \"auth_password\": password or \"\", \"port\": port or 830, \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False), } # will override any of the configs from global nornir config (such as ssh config file) with # options from \"extras\" (connection options) parameters.update(extras) connection = NetconfDriver(**parameters) connection.open() self.connection = connection # pylint: disable=W0201 def close(self) -> None: \"\"\" Close a scrapli netconf connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" self.connection.close()","title":"ScrapliNetconf"},{"location":"api_docs/connection/#methods_1","text":"","title":"Methods"},{"location":"api_docs/connection/#close_1","text":"close(self) \u2011> NoneType Close a scrapli netconf connection to a device Args: N/A Returns: N/A # noqa: DAR202 Raises: N/A","title":"close"},{"location":"api_docs/connection/#open_1","text":"open(self, hostname: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType], port: Union[int, NoneType], platform: Union[str, NoneType], extras: Union[Dict[str, Any], NoneType] = None, configuration: Union[nornir.core.configuration.Config, NoneType] = None) \u2011> NoneType Open a scrapli connection to a device Args: hostname: hostname from nornir inventory username: username from nornir inventory/connection_options for scrapli password: password from nornir inventory/connection_options for scrapli port: port from nornir inventory/connection_options for scrapli platform: platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf extras: extras dict from connection_options for scrapli -- pass all other scrapli arguments here configuration: nornir configuration Returns: N/A # noqa: DAR202 Raises: N/A","title":"open"},{"location":"api_docs/exceptions/","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting()) Module nornir_scrapli.exceptions \u00b6 nornir_scrapli.exceptions Expand source code \"\"\"nornir_scrapli.exceptions\"\"\" class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\" Classes \u00b6 NornirScrapliException \u00b6 nornir_scrapli base exception Expand source code class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\" Ancestors (in MRO) \u00b6 builtins.Exception builtins.BaseException Descendants \u00b6 nornir_scrapli.exceptions.NornirScrapliInvalidPlatform nornir_scrapli.exceptions.NornirScrapliNoConfigModeGenericDriver NornirScrapliInvalidPlatform \u00b6 nornir_scrapli base exception Expand source code class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\" Ancestors (in MRO) \u00b6 nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException NornirScrapliNoConfigModeGenericDriver \u00b6 nornir_scrapli exception for attempting config mode on generic platform Expand source code class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\" Ancestors (in MRO) \u00b6 nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException","title":"Exceptions"},{"location":"api_docs/exceptions/#module-nornir_scrapliexceptions","text":"nornir_scrapli.exceptions Expand source code \"\"\"nornir_scrapli.exceptions\"\"\" class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\" class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\"","title":"Module nornir_scrapli.exceptions"},{"location":"api_docs/exceptions/#classes","text":"","title":"Classes"},{"location":"api_docs/exceptions/#nornirscrapliexception","text":"nornir_scrapli base exception Expand source code class NornirScrapliException(Exception): \"\"\"nornir_scrapli base exception\"\"\"","title":"NornirScrapliException"},{"location":"api_docs/exceptions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#descendants","text":"nornir_scrapli.exceptions.NornirScrapliInvalidPlatform nornir_scrapli.exceptions.NornirScrapliNoConfigModeGenericDriver","title":"Descendants"},{"location":"api_docs/exceptions/#nornirscrapliinvalidplatform","text":"nornir_scrapli base exception Expand source code class NornirScrapliInvalidPlatform(NornirScrapliException): \"\"\"nornir_scrapli base exception\"\"\"","title":"NornirScrapliInvalidPlatform"},{"location":"api_docs/exceptions/#ancestors-in-mro_1","text":"nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#nornirscraplinoconfigmodegenericdriver","text":"nornir_scrapli exception for attempting config mode on generic platform Expand source code class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException): \"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\"","title":"NornirScrapliNoConfigModeGenericDriver"},{"location":"api_docs/exceptions/#ancestors-in-mro_2","text":"nornir_scrapli.exceptions.NornirScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/functions/","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting()) Module nornir_scrapli.functions \u00b6 nornir_scrapli.functions Expand source code \"\"\"nornir_scrapli.functions\"\"\" from nornir_scrapli.functions.print_structured_result import print_structured_result __all__ = (\"print_structured_result\",) Functions \u00b6 print_structured_result \u00b6 print_structured_result(result: nornir.core.task.AggregatedResult, failed: bool = False, severity_level: int = 20, parser: str = 'textfsm', to_dict: bool = True, fail_to_string: bool = False) \u2011> NoneType Prints the :obj:`nornir.core.task.Result` from a previous task to screen Arguments: result: Nornir AggregateResult object from a previous task failed: if `True` assume the task failed severity_level: Print only errors with this severity level or higher parser: textfsm|genie -- parser to parse output with to_dict: output structured data in dict form instead -- basically put k:v instead of just lists of lists of values for textfsm output; ignored if parser == \"genie\" fail_to_string: fallback to printing unstructured output or have tasks skipped (because print_result won't print empty lists which scrapli returns if parsing fails)","title":"Functions"},{"location":"api_docs/functions/#module-nornir_scraplifunctions","text":"nornir_scrapli.functions Expand source code \"\"\"nornir_scrapli.functions\"\"\" from nornir_scrapli.functions.print_structured_result import print_structured_result __all__ = (\"print_structured_result\",)","title":"Module nornir_scrapli.functions"},{"location":"api_docs/functions/#functions","text":"","title":"Functions"},{"location":"api_docs/functions/#print_structured_result","text":"print_structured_result(result: nornir.core.task.AggregatedResult, failed: bool = False, severity_level: int = 20, parser: str = 'textfsm', to_dict: bool = True, fail_to_string: bool = False) \u2011> NoneType Prints the :obj:`nornir.core.task.Result` from a previous task to screen Arguments: result: Nornir AggregateResult object from a previous task failed: if `True` assume the task failed severity_level: Print only errors with this severity level or higher parser: textfsm|genie -- parser to parse output with to_dict: output structured data in dict form instead -- basically put k:v instead of just lists of lists of values for textfsm output; ignored if parser == \"genie\" fail_to_string: fallback to printing unstructured output or have tasks skipped (because print_result won't print empty lists which scrapli returns if parsing fails)","title":"print_structured_result"},{"location":"api_docs/helper/","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting()) Module nornir_scrapli.helper \u00b6 nornir_scrapli.helper Expand source code \"\"\"nornir_scrapli.helper\"\"\" import difflib ANSI_GREEN = \"\\033[92m\" ANSI_RED = \"\\033[91m\" ANSI_END = \"\\033[0m\" def diff_xml_text(document_one: str, document_two: str) -> str: \"\"\" Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A \"\"\" # ignore message-id stuff -- maybe more in the future? document_one_lines = [line for line in document_one.splitlines() if \"message-id\" not in line] document_two_lines = [line for line in document_two.splitlines() if \"message-id\" not in line] diff = difflib.unified_diff(document_one_lines, document_two_lines) diff_lines = [] for line in diff: if line.startswith(\"---\") or line.startswith(\"+++\"): # may as well just strip out the header lines and such, we dont care about them continue if line.startswith(\"+\"): diff_lines.append(f\"{ANSI_GREEN}{line}{ANSI_END}\") elif line.startswith(\"-\"): diff_lines.append(f\"{ANSI_RED}{line}{ANSI_END}\") else: diff_lines.append(line) return \"\\n\".join(diff_lines) Functions \u00b6 diff_xml_text \u00b6 diff_xml_text(document_one: str, document_two: str) \u2011> str Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A","title":"Helper"},{"location":"api_docs/helper/#module-nornir_scraplihelper","text":"nornir_scrapli.helper Expand source code \"\"\"nornir_scrapli.helper\"\"\" import difflib ANSI_GREEN = \"\\033[92m\" ANSI_RED = \"\\033[91m\" ANSI_END = \"\\033[0m\" def diff_xml_text(document_one: str, document_two: str) -> str: \"\"\" Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A \"\"\" # ignore message-id stuff -- maybe more in the future? document_one_lines = [line for line in document_one.splitlines() if \"message-id\" not in line] document_two_lines = [line for line in document_two.splitlines() if \"message-id\" not in line] diff = difflib.unified_diff(document_one_lines, document_two_lines) diff_lines = [] for line in diff: if line.startswith(\"---\") or line.startswith(\"+++\"): # may as well just strip out the header lines and such, we dont care about them continue if line.startswith(\"+\"): diff_lines.append(f\"{ANSI_GREEN}{line}{ANSI_END}\") elif line.startswith(\"-\"): diff_lines.append(f\"{ANSI_RED}{line}{ANSI_END}\") else: diff_lines.append(line) return \"\\n\".join(diff_lines)","title":"Module nornir_scrapli.helper"},{"location":"api_docs/helper/#functions","text":"","title":"Functions"},{"location":"api_docs/helper/#diff_xml_text","text":"diff_xml_text(document_one: str, document_two: str) \u2011> str Diff xml text strings Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now! Args: document_one: string of xml doc 1 document_two: string of xml doc 2 Returns: str: unified diff of the two input documents Raises: N/A","title":"diff_xml_text"},{"location":"api_docs/result/","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting()) Module nornir_scrapli.result \u00b6 nornir_scrapli.result Expand source code \"\"\"nornir_scrapli.result\"\"\" from typing import TYPE_CHECKING, Any, Optional, Union from scrapli.response import MultiResponse, Response from nornir.core.task import Result if TYPE_CHECKING: from nornir.core.inventory import Host # pylint: disable=C0412 def process_command_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" if isinstance(scrapli_response, Response): result: str = scrapli_response.result return result return \"\\n\\n\".join([response.result for response in scrapli_response]) def process_config_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" full_results = \"\" if isinstance(scrapli_response, Response): for config_input, config_result in zip( scrapli_response.channel_input.split(\"\\n\"), scrapli_response.result.split(\"\\n\") ): if config_input == config_result: full_results += f\"{config_input}\\n\" else: full_results += \"\\n\".join([config_input, config_result]) else: for response in scrapli_response: full_results += \"\\n\".join([response.channel_input, response.result]) return full_results class ScrapliResult(Result): # type: ignore def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed(scrapli_response: Optional[Union[Response, MultiResponse]]) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, Response): failed: bool = scrapli_response.failed return failed if any([response.failed for response in scrapli_response]): return True return False Functions \u00b6 process_command_result \u00b6 process_command_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A process_config_result \u00b6 process_config_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A Classes \u00b6 ScrapliResult \u00b6 Result of running individual tasks. Arguments: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead ot this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Attributes: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead ot this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A Expand source code class ScrapliResult(Result): # type: ignore def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed(scrapli_response: Optional[Union[Response, MultiResponse]]) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, Response): failed: bool = scrapli_response.failed return failed if any([response.failed for response in scrapli_response]): return True return False Ancestors (in MRO) \u00b6 nornir.core.task.Result","title":"Result"},{"location":"api_docs/result/#module-nornir_scrapliresult","text":"nornir_scrapli.result Expand source code \"\"\"nornir_scrapli.result\"\"\" from typing import TYPE_CHECKING, Any, Optional, Union from scrapli.response import MultiResponse, Response from nornir.core.task import Result if TYPE_CHECKING: from nornir.core.inventory import Host # pylint: disable=C0412 def process_command_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" if isinstance(scrapli_response, Response): result: str = scrapli_response.result return result return \"\\n\\n\".join([response.result for response in scrapli_response]) def process_config_result(scrapli_response: Union[Response, MultiResponse]) -> str: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A \"\"\" full_results = \"\" if isinstance(scrapli_response, Response): for config_input, config_result in zip( scrapli_response.channel_input.split(\"\\n\"), scrapli_response.result.split(\"\\n\") ): if config_input == config_result: full_results += f\"{config_input}\\n\" else: full_results += \"\\n\".join([config_input, config_result]) else: for response in scrapli_response: full_results += \"\\n\".join([response.channel_input, response.result]) return full_results class ScrapliResult(Result): # type: ignore def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed(scrapli_response: Optional[Union[Response, MultiResponse]]) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, Response): failed: bool = scrapli_response.failed return failed if any([response.failed for response in scrapli_response]): return True return False","title":"Module nornir_scrapli.result"},{"location":"api_docs/result/#functions","text":"","title":"Functions"},{"location":"api_docs/result/#process_command_result","text":"process_command_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A","title":"process_command_result"},{"location":"api_docs/result/#process_config_result","text":"process_config_result(scrapli_response: Union[scrapli.response.Response, scrapli.response.MultiResponse]) \u2011> str Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: str: string result from nornir task or None Raises: N/A","title":"process_config_result"},{"location":"api_docs/result/#classes","text":"","title":"Classes"},{"location":"api_docs/result/#scrapliresult","text":"Result of running individual tasks. Arguments: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead ot this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Attributes: changed (bool): ``True`` if the task is changing the system diff (obj): Diff between state of the system before/after running this task result (obj): Result of the task execution, see task's documentation for details host (:obj:`nornir.core.inventory.Host`): Reference to the host that lead ot this result failed (bool): Whether the execution failed or not severity_level (logging.LEVEL): Severity level associated to the result of the excecution exception (Exception): uncaught exception thrown during the exection of the task (if any) Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A Expand source code class ScrapliResult(Result): # type: ignore def __init__( self, host: \"Host\", result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse]] = None, changed: bool = False, **kwargs: Any, ): \"\"\" Scrapli Nornir Result object A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli Args: host: nornir task host object result: result text returned from scrapli task scrapli_response: original response object returned from scrapli task changed: bool indicating if a change has occurred kwargs: keyword arguments to pass to nornir Result Returns: N/A # noqa: DAR202 Raises: N/A \"\"\" failed = self._process_failed(scrapli_response=scrapli_response) super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs) self.scrapli_response = scrapli_response @staticmethod def _process_failed(scrapli_response: Optional[Union[Response, MultiResponse]]) -> bool: \"\"\" Process and return string of scrapli response(s) Args: scrapli_response: scrapli Response or MultiResponse object Returns: bool: bool indicating if the nornir task failed Raises: N/A \"\"\" if scrapli_response is None: return False if isinstance(scrapli_response, Response): failed: bool = scrapli_response.failed return failed if any([response.failed for response in scrapli_response]): return True return False","title":"ScrapliResult"},{"location":"api_docs/result/#ancestors-in-mro","text":"nornir.core.task.Result","title":"Ancestors (in MRO)"},{"location":"api_docs/tasks/","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting()) Module nornir_scrapli.tasks \u00b6 nornir_scrapli.tasks Expand source code \"\"\"nornir_scrapli.tasks\"\"\" from nornir_scrapli.tasks.get_prompt import get_prompt from nornir_scrapli.tasks.netconf_capabilities import netconf_capabilities from nornir_scrapli.tasks.netconf_commit import netconf_commit from nornir_scrapli.tasks.netconf_delete_config import netconf_delete_config from nornir_scrapli.tasks.netconf_discard import netconf_discard from nornir_scrapli.tasks.netconf_edit_config import netconf_edit_config from nornir_scrapli.tasks.netconf_get import netconf_get from nornir_scrapli.tasks.netconf_get_config import netconf_get_config from nornir_scrapli.tasks.netconf_lock import netconf_lock from nornir_scrapli.tasks.netconf_rpc import netconf_rpc from nornir_scrapli.tasks.netconf_unlock import netconf_unlock from nornir_scrapli.tasks.netconf_validate import netconf_validate from nornir_scrapli.tasks.send_command import send_command from nornir_scrapli.tasks.send_commands import send_commands from nornir_scrapli.tasks.send_commands_from_file import send_commands_from_file from nornir_scrapli.tasks.send_config import send_config from nornir_scrapli.tasks.send_configs import send_configs from nornir_scrapli.tasks.send_configs_from_file import send_configs_from_file from nornir_scrapli.tasks.send_interactive import send_interactive __all__ = ( \"get_prompt\", \"netconf_capabilities\", \"netconf_commit\", \"netconf_delete_config\", \"netconf_discard\", \"netconf_edit_config\", \"netconf_get\", \"netconf_get_config\", \"netconf_lock\", \"netconf_rpc\", \"netconf_unlock\", \"netconf_validate\", \"send_command\", \"send_commands\", \"send_commands_from_file\", \"send_config\", \"send_configs\", \"send_configs_from_file\", \"send_interactive\", ) Functions \u00b6 get_prompt \u00b6 get_prompt(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Get current prompt from device using scrapli Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to current prompt Raises: N/A netconf_capabilities \u00b6 netconf_capabilities(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Retrieve the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to a list of strings representing the device capabilities Raises: N/A netconf_commit \u00b6 netconf_commit(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Commit the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_delete_config \u00b6 netconf_delete_config(task: nornir.core.task.Task, target: str = 'candidate') \u2011> nornir.core.task.Result Send a \"delete-config\" rcp to the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the delete operation Raises: N/A netconf_discard \u00b6 netconf_discard(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Discard the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_edit_config \u00b6 netconf_edit_config(task: nornir.core.task.Task, config: str, dry_run: Union[bool, NoneType] = None, diff: bool = False, target: str = 'running') \u2011> nornir.core.task.Result Edit config from the device with scrapli_netconf Args: task: nornir task object config: configuration to send to device dry_run: if True config will be pushed and then discarded; will discard anything already pushed that has *not* been committed already, so be careful! :D; also note that this will only work if there is a candidate datastore -- meaning that, for example, with IOSXE with a target of \"running\" there is no way to discard the configuration as it will already have been written to the running datastore diff: capture/set diff of target datastore xml text of before/after edit config operation target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A netconf_get \u00b6 netconf_get(task: nornir.core.task.Task, filter_: str, filter_type: str = 'subtree') \u2011> nornir.core.task.Result Get from the device with scrapli_netconf Args: task: nornir task object filter_: string filter to apply to the get filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_get_config \u00b6 netconf_get_config(task: nornir.core.task.Task, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') \u2011> nornir.core.task.Result Get config from the device with scrapli_netconf Args: task: nornir task object source: configuration source to get; typically one of running|startup|candidate filters: string or list of strings of filters to apply to configuration filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A netconf_lock \u00b6 netconf_lock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result Lock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_rpc \u00b6 netconf_rpc(task: nornir.core.task.Task, filter_: str) \u2011> nornir.core.task.Result Send a \"bare\" rcp to the device with scrapli_netconf Args: task: nornir task object filter_: filter/rpc to execute Returns: Result: nornir result object with Result.result value set the string result of the rpc operation Raises: N/A netconf_unlock \u00b6 netconf_unlock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result Unlock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A netconf_validate \u00b6 netconf_validate(task: nornir.core.task.Task, source: str) \u2011> nornir.core.task.Result Send a \"validate\" rcp to the device with scrapli_netconf Args: task: nornir task object source: configuration source to validate; typically one of running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A send_command \u00b6 send_command(task: nornir.core.task.Task, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a single command to device using scrapli Args: task: nornir task object command: string to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: scrapli nornir result object; almost identical to a \"normal\" nornir result object, but contains an additional attribute \"scrapli_response\" that contains the original response from scrapli Raises: N/A send_commands \u00b6 send_commands(task: nornir.core.task.Task, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a list of commands to device using scrapli Args: task: nornir task object commands: list of strings to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A send_commands_from_file \u00b6 send_commands_from_file(task: nornir.core.task.Task, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a list of commands from a file to device using scrapli Args: task: nornir task object file: string path to file strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A send_config \u00b6 send_config(task: nornir.core.task.Task, config: str, dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a config to device using scrapli Args: task: nornir task object config: string configuration to send to the device, supports sending multi-line strings dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type send_configs \u00b6 send_configs(task: nornir.core.task.Task, configs: List[str], dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send configs to device using scrapli Args: task: nornir task object configs: list of strings to send to device in config mode dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type send_configs_from_file \u00b6 send_configs_from_file(task: nornir.core.task.Task, file: str, dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send configs from a file to device using scrapli Args: task: nornir task object file: string path to file dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type send_interactive \u00b6 send_interactive(task: nornir.core.task.Task, interact_events: List[Tuple[str, str, Union[bool, NoneType]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '', timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send inputs in an interactive fashion using scrapli; usually used to handle prompts Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input) An example where we need this sort of capability: 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password: Password: Sink: C0644 639 test1.txt ! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# To accomplish this we can use the following (in \"native\" scrapli): interact = conn.channel.send_inputs_interact( [ (\"copy flash: scp:\", \"Source filename []?\", False), (\"test1.txt\", \"Address or name of remote host []?\", False), (\"172.31.254.100\", \"Destination username [carl]?\", False), (\"carl\", \"Password:\", False), (\"super_secure_password\", prompt, True), ] ) If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\" . Args : task : nornir task object interact_events : list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response , and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" ( ex : password ), if the hidden param is not provided it is assumed the input is \"normal\" ( not hidden ) failed_when_contains : list of strings that , if present in final output , represent a failed command / interaction privilege_level : name of the privilege level to operate in timeout_ops : timeout ops value for this operation ; only sets the timeout_ops value for the duration of the operation , value is reset to initial value after operation is completed Returns : Result : nornir result object with Result . result value set to returned scrapli Response object Raises : N / A","title":"Tasks"},{"location":"api_docs/tasks/#module-nornir_scraplitasks","text":"nornir_scrapli.tasks Expand source code \"\"\"nornir_scrapli.tasks\"\"\" from nornir_scrapli.tasks.get_prompt import get_prompt from nornir_scrapli.tasks.netconf_capabilities import netconf_capabilities from nornir_scrapli.tasks.netconf_commit import netconf_commit from nornir_scrapli.tasks.netconf_delete_config import netconf_delete_config from nornir_scrapli.tasks.netconf_discard import netconf_discard from nornir_scrapli.tasks.netconf_edit_config import netconf_edit_config from nornir_scrapli.tasks.netconf_get import netconf_get from nornir_scrapli.tasks.netconf_get_config import netconf_get_config from nornir_scrapli.tasks.netconf_lock import netconf_lock from nornir_scrapli.tasks.netconf_rpc import netconf_rpc from nornir_scrapli.tasks.netconf_unlock import netconf_unlock from nornir_scrapli.tasks.netconf_validate import netconf_validate from nornir_scrapli.tasks.send_command import send_command from nornir_scrapli.tasks.send_commands import send_commands from nornir_scrapli.tasks.send_commands_from_file import send_commands_from_file from nornir_scrapli.tasks.send_config import send_config from nornir_scrapli.tasks.send_configs import send_configs from nornir_scrapli.tasks.send_configs_from_file import send_configs_from_file from nornir_scrapli.tasks.send_interactive import send_interactive __all__ = ( \"get_prompt\", \"netconf_capabilities\", \"netconf_commit\", \"netconf_delete_config\", \"netconf_discard\", \"netconf_edit_config\", \"netconf_get\", \"netconf_get_config\", \"netconf_lock\", \"netconf_rpc\", \"netconf_unlock\", \"netconf_validate\", \"send_command\", \"send_commands\", \"send_commands_from_file\", \"send_config\", \"send_configs\", \"send_configs_from_file\", \"send_interactive\", )","title":"Module nornir_scrapli.tasks"},{"location":"api_docs/tasks/#functions","text":"","title":"Functions"},{"location":"api_docs/tasks/#get_prompt","text":"get_prompt(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Get current prompt from device using scrapli Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to current prompt Raises: N/A","title":"get_prompt"},{"location":"api_docs/tasks/#netconf_capabilities","text":"netconf_capabilities(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Retrieve the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set to a list of strings representing the device capabilities Raises: N/A","title":"netconf_capabilities"},{"location":"api_docs/tasks/#netconf_commit","text":"netconf_commit(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Commit the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_commit"},{"location":"api_docs/tasks/#netconf_delete_config","text":"netconf_delete_config(task: nornir.core.task.Task, target: str = 'candidate') \u2011> nornir.core.task.Result Send a \"delete-config\" rcp to the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the delete operation Raises: N/A","title":"netconf_delete_config"},{"location":"api_docs/tasks/#netconf_discard","text":"netconf_discard(task: nornir.core.task.Task) \u2011> nornir.core.task.Result Discard the device config with scrapli_netconf Args: task: nornir task object Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_discard"},{"location":"api_docs/tasks/#netconf_edit_config","text":"netconf_edit_config(task: nornir.core.task.Task, config: str, dry_run: Union[bool, NoneType] = None, diff: bool = False, target: str = 'running') \u2011> nornir.core.task.Result Edit config from the device with scrapli_netconf Args: task: nornir task object config: configuration to send to device dry_run: if True config will be pushed and then discarded; will discard anything already pushed that has *not* been committed already, so be careful! :D; also note that this will only work if there is a candidate datastore -- meaning that, for example, with IOSXE with a target of \"running\" there is no way to discard the configuration as it will already have been written to the running datastore diff: capture/set diff of target datastore xml text of before/after edit config operation target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A","title":"netconf_edit_config"},{"location":"api_docs/tasks/#netconf_get","text":"netconf_get(task: nornir.core.task.Task, filter_: str, filter_type: str = 'subtree') \u2011> nornir.core.task.Result Get from the device with scrapli_netconf Args: task: nornir task object filter_: string filter to apply to the get filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_get"},{"location":"api_docs/tasks/#netconf_get_config","text":"netconf_get_config(task: nornir.core.task.Task, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') \u2011> nornir.core.task.Result Get config from the device with scrapli_netconf Args: task: nornir task object source: configuration source to get; typically one of running|startup|candidate filters: string or list of strings of filters to apply to configuration filter_type: type of filter; subtree|xpath Returns: Result: nornir result object with Result.result value set the string result of the get_config operation Raises: N/A","title":"netconf_get_config"},{"location":"api_docs/tasks/#netconf_lock","text":"netconf_lock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result Lock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_lock"},{"location":"api_docs/tasks/#netconf_rpc","text":"netconf_rpc(task: nornir.core.task.Task, filter_: str) \u2011> nornir.core.task.Result Send a \"bare\" rcp to the device with scrapli_netconf Args: task: nornir task object filter_: filter/rpc to execute Returns: Result: nornir result object with Result.result value set the string result of the rpc operation Raises: N/A","title":"netconf_rpc"},{"location":"api_docs/tasks/#netconf_unlock","text":"netconf_unlock(task: nornir.core.task.Task, target: str) \u2011> nornir.core.task.Result Unlock the device with scrapli_netconf Args: task: nornir task object target: configuration source to target; running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_unlock"},{"location":"api_docs/tasks/#netconf_validate","text":"netconf_validate(task: nornir.core.task.Task, source: str) \u2011> nornir.core.task.Result Send a \"validate\" rcp to the device with scrapli_netconf Args: task: nornir task object source: configuration source to validate; typically one of running|startup|candidate Returns: Result: nornir result object with Result.result value set the string result of the get operation Raises: N/A","title":"netconf_validate"},{"location":"api_docs/tasks/#send_command","text":"send_command(task: nornir.core.task.Task, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a single command to device using scrapli Args: task: nornir task object command: string to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: scrapli nornir result object; almost identical to a \"normal\" nornir result object, but contains an additional attribute \"scrapli_response\" that contains the original response from scrapli Raises: N/A","title":"send_command"},{"location":"api_docs/tasks/#send_commands","text":"send_commands(task: nornir.core.task.Task, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a list of commands to device using scrapli Args: task: nornir task object commands: list of strings to send to device in privilege exec mode strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A","title":"send_commands"},{"location":"api_docs/tasks/#send_commands_from_file","text":"send_commands_from_file(task: nornir.core.task.Task, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a list of commands from a file to device using scrapli Args: task: nornir task object file: string path to file strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: N/A","title":"send_commands_from_file"},{"location":"api_docs/tasks/#send_config","text":"send_config(task: nornir.core.task.Task, config: str, dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send a config to device using scrapli Args: task: nornir task object config: string configuration to send to the device, supports sending multi-line strings dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type","title":"send_config"},{"location":"api_docs/tasks/#send_configs","text":"send_configs(task: nornir.core.task.Task, configs: List[str], dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send configs to device using scrapli Args: task: nornir task object configs: list of strings to send to device in config mode dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type","title":"send_configs"},{"location":"api_docs/tasks/#send_configs_from_file","text":"send_configs_from_file(task: nornir.core.task.Task, file: str, dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send configs from a file to device using scrapli Args: task: nornir task object file: string path to file dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs strip_prompt: True/False strip prompt from returned output failed_when_contains: string or list of strings indicating failure if found in response stop_on_failed: True/False stop executing commands if a command fails, returns results as of current execution privilege_level: name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver. eager: if eager is True we do not read until prompt is seen at each command sent to the channel. Do *not* use this unless you know what you are doing as it is possible that it can make scrapli less reliable! timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent! Returns: Result: nornir result object with Result.result value set to returned scrapli Response object Raises: NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a host that is using the \"generic\" platform type","title":"send_configs_from_file"},{"location":"api_docs/tasks/#send_interactive","text":"send_interactive(task: nornir.core.task.Task, interact_events: List[Tuple[str, str, Union[bool, NoneType]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '', timeout_ops: Union[float, NoneType] = None) \u2011> nornir.core.task.Result Send inputs in an interactive fashion using scrapli; usually used to handle prompts Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input) An example where we need this sort of capability: 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password: Password: Sink: C0644 639 test1.txt ! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# To accomplish this we can use the following (in \"native\" scrapli): interact = conn.channel.send_inputs_interact( [ (\"copy flash: scp:\", \"Source filename []?\", False), (\"test1.txt\", \"Address or name of remote host []?\", False), (\"172.31.254.100\", \"Destination username [carl]?\", False), (\"carl\", \"Password:\", False), (\"super_secure_password\", prompt, True), ] ) If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\" . Args : task : nornir task object interact_events : list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response , and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" ( ex : password ), if the hidden param is not provided it is assumed the input is \"normal\" ( not hidden ) failed_when_contains : list of strings that , if present in final output , represent a failed command / interaction privilege_level : name of the privilege level to operate in timeout_ops : timeout ops value for this operation ; only sets the timeout_ops value for the duration of the operation , value is reset to initial value after operation is completed Returns : Result : nornir result object with Result . result value set to returned scrapli Response object Raises : N / A","title":"send_interactive"},{"location":"more_scrapli/scrapli/","text":"scrapli \u00b6 scrapli ( docs ) is the \"parent\" library on which scrapli_netconf is built. Check it out if you need to connect to devices with telnet or ssh!","title":"Scrapli"},{"location":"more_scrapli/scrapli/#scrapli","text":"scrapli ( docs ) is the \"parent\" library on which scrapli_netconf is built. Check it out if you need to connect to devices with telnet or ssh!","title":"scrapli"},{"location":"more_scrapli/scrapli_community/","text":"scrapli Community \u00b6 If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_community/#scrapli-community","text":"If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"scrapli Community"},{"location":"more_scrapli/scrapli_netconf/","text":"scrapli Netconf \u00b6 scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_netconf/#scrapli-netconf","text":"scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"scrapli Netconf"},{"location":"more_scrapli/scrapli_stubs/","text":"scrapli Stubs \u00b6 Do you REALLY love typing and scrapli? Great news, type stubs for scrapli are generated periodically and updated here , enjoy!","title":"Scrapli Stubs"},{"location":"more_scrapli/scrapli_stubs/#scrapli-stubs","text":"Do you REALLY love typing and scrapli? Great news, type stubs for scrapli are generated periodically and updated here , enjoy!","title":"scrapli Stubs"},{"location":"user_guide/available_functions/","text":"Available Functions \u00b6 print_structured_result -- this function is very similar to the \"normal\" print_result function that now ships with the nornir_utils library (historically with nornir \"core\"), except it contains several additional arguments, most importantly the parser argument allows you to select textfsm or genie to decide which parser to use to parse the unstructured data stored in the results object. Please see the structured results example here for more details.","title":"Available Functions"},{"location":"user_guide/available_functions/#available-functions","text":"print_structured_result -- this function is very similar to the \"normal\" print_result function that now ships with the nornir_utils library (historically with nornir \"core\"), except it contains several additional arguments, most importantly the parser argument allows you to select textfsm or genie to decide which parser to use to parse the unstructured data stored in the results object. Please see the structured results example here for more details.","title":"Available Functions"},{"location":"user_guide/available_tasks/","text":"Available Tasks \u00b6 All tasks presented here are methods that live in scrapli or scrapli_netconf -- these tasks are simply \"wrapped \" in such a way that they may be used within the constructs of nornir ! The links below link back to the scrapli or scrapli_netconf docs for the given method -- in all (or very nearly all?) cases, the same arguments that the underlying library supports will be exposed to nornir ! Scrapli \"core\" Tasks \u00b6 get_prompt - Get the current prompt of the device send_command - Send a single command to the device send_commands - Send a list of commands to the device send_commands_from_file - Send a list of commands from a file to the device send_config - Send a configuration to the device send_configs - Send a list of configurations to the device send_configs_from_file - Send a list of configurations from a file to the device send_interactive -\"Interact\" with the device (handle prompts and inputs and things like that) Scrapli Netconf Tasks \u00b6 Note that not all devices will support all operations! netconf_capabilities - Get list of capabilities as exchanged during netconf connection establishment netconf_commit - Commit the configuration on the device netconf_discard - Discard the configuration on the device netconf_edit_config - Edit the configuration on the device netconf_delete_config - Delete a given datastore on the device netconf_get - Get a subtree or xpath from the device netconf_get_config - Get the configuration from the device netconf_lock - Lock the datastore on the device netconf_unlock - Unlock the datastore on the device netconf_rpc - Send a \"bare\" RPC to the device netconf_validate - Execute the validate rpc against a given datastore","title":"Available Tasks"},{"location":"user_guide/available_tasks/#available-tasks","text":"All tasks presented here are methods that live in scrapli or scrapli_netconf -- these tasks are simply \"wrapped \" in such a way that they may be used within the constructs of nornir ! The links below link back to the scrapli or scrapli_netconf docs for the given method -- in all (or very nearly all?) cases, the same arguments that the underlying library supports will be exposed to nornir !","title":"Available Tasks"},{"location":"user_guide/available_tasks/#scrapli-core-tasks","text":"get_prompt - Get the current prompt of the device send_command - Send a single command to the device send_commands - Send a list of commands to the device send_commands_from_file - Send a list of commands from a file to the device send_config - Send a configuration to the device send_configs - Send a list of configurations to the device send_configs_from_file - Send a list of configurations from a file to the device send_interactive -\"Interact\" with the device (handle prompts and inputs and things like that)","title":"Scrapli \"core\" Tasks"},{"location":"user_guide/available_tasks/#scrapli-netconf-tasks","text":"Note that not all devices will support all operations! netconf_capabilities - Get list of capabilities as exchanged during netconf connection establishment netconf_commit - Commit the configuration on the device netconf_discard - Discard the configuration on the device netconf_edit_config - Edit the configuration on the device netconf_delete_config - Delete a given datastore on the device netconf_get - Get a subtree or xpath from the device netconf_get_config - Get the configuration from the device netconf_lock - Lock the datastore on the device netconf_unlock - Unlock the datastore on the device netconf_rpc - Send a \"bare\" RPC to the device netconf_validate - Execute the validate rpc against a given datastore","title":"Scrapli Netconf Tasks"},{"location":"user_guide/basic_usage/","text":"Basic Usage \u00b6 Basic Information/Usage \u00b6 Nornir has historically contained it's plugins within the actual Nornir codebase itself, this however has changed! As of mid September 2020, Nornir 3.0.0 has been officially released -- this move to the 3.x.x version now expects plugins to be external to the code base. If you are looking for pre 3.x.x support, please use the 2020.09.01 version. If you have used Nornir before (pre 3.x.x), this package should be very similar to what you already know. Since the plugins used to live in Nornir you could simply import them from the appropriate package as such: from nornir.plugins.tasks.networking import netconf_get_config With nornir_scrapli you simply install this package along side \"regular\" Nornir, and import the tasks from nornir_scrapli directly: from nornir_scrapli.tasks import send_command As soon as a nornir_scrapli task is imported, it ( nornir_scrapli ) will register as a connection, and things should work as normal from there! The last important difference with nornir_scrapli is that in addition to the \"normal\" data in the Nornir Result object, nornir_scrapli also assigns the scrapli Response object (or list of Response objects) to the scrapli_response attribute. This means that you can access all of the \"normal\" scrapli response data from this object -- including things like elapsed_time and textfsm_parse_output : >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . elapsed_time 0.039469 >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . textfsm_parse_output () [[ some structured data back from the device ! ]] If you would like to continue using print_result like \"normal\" in nornir, but would like to see structured data (if available) in the print_result output, you can use the nornir_scrapli print_structured_result function. This function can be imported from the scrapli functions module: from nornir_scrapli.functions import print_structured_result This function acts pretty much exactly like the \"normal\" print result function, but will of course try to print the structured result. By default this will try to use textfsm to parse results, but it is of course configurable via the parser keyword argument. As scrapli will return an empty data structure if parsing fails, this may cause tasks to look like they are getting skipped in the output (nornir's print result function does not print empty lists), if you would like to fall back to printing the unparsed output you can do so by setting the fail_to_string keyword argument to True as follows: print_structured_result ( my_agg_result , parser = \"genie\" , fail_to_string = True ) Using Different Transports \u00b6 nornir_scrapli supports all synchronous scrapli transport plugins. By default, the \"system\" transport will be used, however you can change this in the extras section of your nornir inventory: connection_options : scrapli : port : 22 extras : ssh_config_file : True auth_strict_key : False transport : ssh2 Note that you will need to install scrapli_ssh2 or scrapli_paramiko if you want to use those transport plugins!","title":"Basic Usage"},{"location":"user_guide/basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"user_guide/basic_usage/#basic-informationusage","text":"Nornir has historically contained it's plugins within the actual Nornir codebase itself, this however has changed! As of mid September 2020, Nornir 3.0.0 has been officially released -- this move to the 3.x.x version now expects plugins to be external to the code base. If you are looking for pre 3.x.x support, please use the 2020.09.01 version. If you have used Nornir before (pre 3.x.x), this package should be very similar to what you already know. Since the plugins used to live in Nornir you could simply import them from the appropriate package as such: from nornir.plugins.tasks.networking import netconf_get_config With nornir_scrapli you simply install this package along side \"regular\" Nornir, and import the tasks from nornir_scrapli directly: from nornir_scrapli.tasks import send_command As soon as a nornir_scrapli task is imported, it ( nornir_scrapli ) will register as a connection, and things should work as normal from there! The last important difference with nornir_scrapli is that in addition to the \"normal\" data in the Nornir Result object, nornir_scrapli also assigns the scrapli Response object (or list of Response objects) to the scrapli_response attribute. This means that you can access all of the \"normal\" scrapli response data from this object -- including things like elapsed_time and textfsm_parse_output : >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . elapsed_time 0.039469 >>> some_nornir_result [ \"sea-ios-1\" ] . scrapli_response . textfsm_parse_output () [[ some structured data back from the device ! ]] If you would like to continue using print_result like \"normal\" in nornir, but would like to see structured data (if available) in the print_result output, you can use the nornir_scrapli print_structured_result function. This function can be imported from the scrapli functions module: from nornir_scrapli.functions import print_structured_result This function acts pretty much exactly like the \"normal\" print result function, but will of course try to print the structured result. By default this will try to use textfsm to parse results, but it is of course configurable via the parser keyword argument. As scrapli will return an empty data structure if parsing fails, this may cause tasks to look like they are getting skipped in the output (nornir's print result function does not print empty lists), if you would like to fall back to printing the unparsed output you can do so by setting the fail_to_string keyword argument to True as follows: print_structured_result ( my_agg_result , parser = \"genie\" , fail_to_string = True )","title":"Basic Information/Usage"},{"location":"user_guide/basic_usage/#using-different-transports","text":"nornir_scrapli supports all synchronous scrapli transport plugins. By default, the \"system\" transport will be used, however you can change this in the extras section of your nornir inventory: connection_options : scrapli : port : 22 extras : ssh_config_file : True auth_strict_key : False transport : ssh2 Note that you will need to install scrapli_ssh2 or scrapli_paramiko if you want to use those transport plugins!","title":"Using Different Transports"},{"location":"user_guide/installation/","text":"Installation \u00b6 Standard Installation \u00b6 As outlined in the quick start, you should be able to pip install scrapli \"normally\": pip install nornir-scrapli Installing current master branch \u00b6 To install from the source repositories master branch: pip install git+https://github.com/scrapli/nornir_scrapli Installing current develop branch \u00b6 To install from this repositories develop branch: pip install -e git+https://github.com/scrapli/nornir_scrapli.git@develop#egg=nornir_scrapli Installation from Source \u00b6 To install from source: git clone https://github.com/scrapli/nornir_scrapli cd nornir_scrapli python setup.py install Supported Platforms \u00b6 As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Installation"},{"location":"user_guide/installation/#installation","text":"","title":"Installation"},{"location":"user_guide/installation/#standard-installation","text":"As outlined in the quick start, you should be able to pip install scrapli \"normally\": pip install nornir-scrapli","title":"Standard Installation"},{"location":"user_guide/installation/#installing-current-master-branch","text":"To install from the source repositories master branch: pip install git+https://github.com/scrapli/nornir_scrapli","title":"Installing current master branch"},{"location":"user_guide/installation/#installing-current-develop-branch","text":"To install from this repositories develop branch: pip install -e git+https://github.com/scrapli/nornir_scrapli.git@develop#egg=nornir_scrapli","title":"Installing current develop branch"},{"location":"user_guide/installation/#installation-from-source","text":"To install from source: git clone https://github.com/scrapli/nornir_scrapli cd nornir_scrapli python setup.py install","title":"Installation from Source"},{"location":"user_guide/installation/#supported-platforms","text":"As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Supported Platforms"},{"location":"user_guide/project_details/","text":"Project Details \u00b6 What is nornir_scrapli \u00b6 nornir_scrapli is scrapli (and scrapli netconf's) plugin for Nornir. Nearly all (synchronous) methods of scrapli are available/exposed in nornir scrapli. So if you enjoy scrapli, but also want the built-in concurrency and inventory management afforded by nornir, this is the place to be! Supported Platforms \u00b6 nornir_scrapli supports the \"core\" scrapli drivers, the GenericDriver (for use with linux hosts generally speaking ), and the scrapli_community platforms as well! See scrapli core docs and the scrapli community docs for more info. The platform argument in the inventory data should use the \"normal\" NAPALM style platform names, generic , or the name of the scrapli_community platform (i.e. huawei_vrp )). Example platform values (for inventory data): platform : cisco_iosxe platform : cisco_iosxr platform : cisco_nxos platform : arista_eos platform : juniper_junos platform : generic platform : huawei_vrp Related Scrapli Libraries \u00b6 This repo is the nornir plugin for scrapli, however there are other libraries/repos in the scrapli family -- here is a list/link to all of the other scrapli things! scrapli scrapli_community scrapli_netconf scrapli_stubs","title":"Project Details"},{"location":"user_guide/project_details/#project-details","text":"","title":"Project Details"},{"location":"user_guide/project_details/#what-is-nornir_scrapli","text":"nornir_scrapli is scrapli (and scrapli netconf's) plugin for Nornir. Nearly all (synchronous) methods of scrapli are available/exposed in nornir scrapli. So if you enjoy scrapli, but also want the built-in concurrency and inventory management afforded by nornir, this is the place to be!","title":"What is nornir_scrapli"},{"location":"user_guide/project_details/#supported-platforms","text":"nornir_scrapli supports the \"core\" scrapli drivers, the GenericDriver (for use with linux hosts generally speaking ), and the scrapli_community platforms as well! See scrapli core docs and the scrapli community docs for more info. The platform argument in the inventory data should use the \"normal\" NAPALM style platform names, generic , or the name of the scrapli_community platform (i.e. huawei_vrp )). Example platform values (for inventory data): platform : cisco_iosxe platform : cisco_iosxr platform : cisco_nxos platform : arista_eos platform : juniper_junos platform : generic platform : huawei_vrp","title":"Supported Platforms"},{"location":"user_guide/project_details/#related-scrapli-libraries","text":"This repo is the nornir plugin for scrapli, however there are other libraries/repos in the scrapli family -- here is a list/link to all of the other scrapli things! scrapli scrapli_community scrapli_netconf scrapli_stubs","title":"Related Scrapli Libraries"},{"location":"user_guide/quickstart/","text":"Quick Start Guide \u00b6 Installation \u00b6 In most cases installation via pip is the simplest and best way to install nornir_scrapli. pip install nornir-scrapli A Simple Example \u00b6 Example config file: --- inventory : plugin : YAMLInventory options : host_file : \"nornir_data/hosts.yaml\" group_file : \"nornir_data/groups.yaml\" defaults_file : \"nornir_data/defaults.yaml\" Example inventory file (host/group/default, see \"real\" Nornir docs for lots more info!) -- please notice that there is a scrapli and a scrapli_netconf connection type here!: --- iosxe-1 : hostname : 172.18.0.11 connection_options : scrapli : platform : cisco_iosxe port : 22 extras : ssh_config_file : True auth_strict_key : False scrapli_netconf : port : 830 extras : ssh_config_file : True auth_strict_key : False NOTE: scrapli-netconf has no concept (at the moment!) of \"platforms\" - it simply implements RFC compliant NETCONF RPCs, so you do not need to pass iosxr , junos or anything like that to the scrapli_netconf connection options section! from nornir import InitNornir from nornir_scrapli.tasks import ( get_prompt , send_command , send_configs ) nr = InitNornir ( config_file = \"nornir_data/config.yaml\" ) prompt_results = nr . run ( task = get_prompt ) command_results = nr . run ( task = send_command , command = \"show version\" ) config_results = nr . run ( task = send_configs , configs = [ \"interface loopback123\" , \"description nornir_scrapli was here\" ], ) print ( \"get_prompt result:\" ) print ( prompt_results [ \"iosxe-1\" ] . result ) print ( \"send_command result:\" ) print ( command_results [ \"iosxe-1\" ] . result ) print ( \"send_configs result:\" ) print ( config_results [ \"iosxe-1\" ] . result ) $ python my_scrapli_script.py get_prompt result: 3560CX# send_command result: Cisco IOS Software, C3560CX Software ( C3560CX-UNIVERSALK9-M ) , Version 15 .2 ( 4 ) E7, RELEASE SOFTWARE ( fc2 ) <SNIP> send_configs result: Netconf tasks are imported from the same package and in the same fashion as the \"core\" scrapli tasks: from nornir_scrapli.tasks import ( netconf_lock , netconf_unlock , netconf_edit_config , netconf_get , netconf_get_config , netconf_rpc ) And are executed in the same fashion as well: config = \"\"\"<config> <interfaces xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\"> <interface> <name>GigabitEthernet1</name> <description>scrapli was here!</description> </interface> </interfaces> </config>\"\"\" result = nr . run ( task = netconf_edit_config , config = config ) print ( result [ 'iosxe1' ][ 0 ] . result ) print ( result [ 'iosxe1' ][ 0 ] . scrapli_response . xml_result ) When using the scrapli-netconf tasks the result object result will be the string of the returned data from the device. As with all other nornir-scrapli results, the scrapli_response object will be assigned to the Result object and will contain all of the \"normal\" scrapli response object data (or scrapli-netconf response data ), such as the elapsed_time , raw_result , xml_result , etc. -- you can see this in the above example! Additional Examples \u00b6 NETCONF Usage Structured Data","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#installation","text":"In most cases installation via pip is the simplest and best way to install nornir_scrapli. pip install nornir-scrapli","title":"Installation"},{"location":"user_guide/quickstart/#a-simple-example","text":"Example config file: --- inventory : plugin : YAMLInventory options : host_file : \"nornir_data/hosts.yaml\" group_file : \"nornir_data/groups.yaml\" defaults_file : \"nornir_data/defaults.yaml\" Example inventory file (host/group/default, see \"real\" Nornir docs for lots more info!) -- please notice that there is a scrapli and a scrapli_netconf connection type here!: --- iosxe-1 : hostname : 172.18.0.11 connection_options : scrapli : platform : cisco_iosxe port : 22 extras : ssh_config_file : True auth_strict_key : False scrapli_netconf : port : 830 extras : ssh_config_file : True auth_strict_key : False NOTE: scrapli-netconf has no concept (at the moment!) of \"platforms\" - it simply implements RFC compliant NETCONF RPCs, so you do not need to pass iosxr , junos or anything like that to the scrapli_netconf connection options section! from nornir import InitNornir from nornir_scrapli.tasks import ( get_prompt , send_command , send_configs ) nr = InitNornir ( config_file = \"nornir_data/config.yaml\" ) prompt_results = nr . run ( task = get_prompt ) command_results = nr . run ( task = send_command , command = \"show version\" ) config_results = nr . run ( task = send_configs , configs = [ \"interface loopback123\" , \"description nornir_scrapli was here\" ], ) print ( \"get_prompt result:\" ) print ( prompt_results [ \"iosxe-1\" ] . result ) print ( \"send_command result:\" ) print ( command_results [ \"iosxe-1\" ] . result ) print ( \"send_configs result:\" ) print ( config_results [ \"iosxe-1\" ] . result ) $ python my_scrapli_script.py get_prompt result: 3560CX# send_command result: Cisco IOS Software, C3560CX Software ( C3560CX-UNIVERSALK9-M ) , Version 15 .2 ( 4 ) E7, RELEASE SOFTWARE ( fc2 ) <SNIP> send_configs result: Netconf tasks are imported from the same package and in the same fashion as the \"core\" scrapli tasks: from nornir_scrapli.tasks import ( netconf_lock , netconf_unlock , netconf_edit_config , netconf_get , netconf_get_config , netconf_rpc ) And are executed in the same fashion as well: config = \"\"\"<config> <interfaces xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\"> <interface> <name>GigabitEthernet1</name> <description>scrapli was here!</description> </interface> </interfaces> </config>\"\"\" result = nr . run ( task = netconf_edit_config , config = config ) print ( result [ 'iosxe1' ][ 0 ] . result ) print ( result [ 'iosxe1' ][ 0 ] . scrapli_response . xml_result ) When using the scrapli-netconf tasks the result object result will be the string of the returned data from the device. As with all other nornir-scrapli results, the scrapli_response object will be assigned to the Result object and will contain all of the \"normal\" scrapli response object data (or scrapli-netconf response data ), such as the elapsed_time , raw_result , xml_result , etc. -- you can see this in the above example!","title":"A Simple Example"},{"location":"user_guide/quickstart/#additional-examples","text":"NETCONF Usage Structured Data","title":"Additional Examples"},{"location":"user_guide/versioning/","text":"Versioning \u00b6 Please see the scrapli \"core\" here documentation for versioning information.","title":"Versioning"},{"location":"user_guide/versioning/#versioning","text":"Please see the scrapli \"core\" here documentation for versioning information.","title":"Versioning"}]}