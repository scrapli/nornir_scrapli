{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nornir_scrapli","text":"<p>nornir_scrapli -- scrapli's and scrapli_netconf's plugin for nornir!</p>"},{"location":"about/code_of_conduct/","title":"Code of Conduct","text":"<p>Be excellent to each other!</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>Thanks for thinking about contributing! Contributions are not expected, but are quite welcome.</p> <p>Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds.</p> <p>Some notes on contributing:</p> <ul> <li>Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR,   this way everyone has a chance to chime in and make sure we're all on the same page!</li> <li>Please open an issue to discuss any bugs/bug fixes prior to opening a PR.</li> <li>Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated!</li> <li>All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing.</li> <li>Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future    don't break functionality or make things act in unexpected ways!</li> </ul>"},{"location":"more_scrapli/scrapli/","title":"Scrapli","text":"<p>scrapli (docs) is the  \"parent\" scrapli library. Check it out if you need to connect to devices with telnet or ssh!</p>"},{"location":"more_scrapli/scrapli_cfg/","title":"Scrapli Cfg","text":"<p>scrapli_cfg (docs)  is utility that accepts a scrapli Telnet or SSH connection and provides configuration management capabilities.  scrapli_cfg allows you to load candidate configurations for merge or replace operations, generate diffs of the  current vs candidate, and of course commit or abort the candidate configuration.</p>"},{"location":"more_scrapli/scrapli_community/","title":"Scrapli Community","text":"<p>If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli  platforms, you should check out scrapli_community! This is the place  for users to share \"non-core\" scrapli platforms.</p>"},{"location":"more_scrapli/scrapli_netconf/","title":"Scrapli Netconf","text":"<p>scrapli_netconf (docs)  is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible,  thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage.  Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when  automating devices over telnet, SSH, or netconf (over SSH).</p>"},{"location":"more_scrapli/scrapli_replay/","title":"Scrapli Replay","text":"<p>scrapli_replay (docs)  is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command  input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that  patches and records and replays session data (like vcr.py) for scrapli connections. </p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>connection</li> <li>exceptions</li> <li>functions<ul> <li>print_structured_result</li> </ul> </li> <li>helper</li> <li>result</li> <li>tasks<ul> <li>cfg<ul> <li>abort_config</li> <li>commit_config</li> <li>diff_config</li> <li>get_config</li> <li>get_version</li> <li>load_config</li> </ul> </li> <li>core<ul> <li>get_prompt</li> <li>send_command</li> <li>send_commands</li> <li>send_commands_from_file</li> <li>send_config</li> <li>send_configs</li> <li>send_configs_from_file</li> <li>send_interactive</li> </ul> </li> <li>netconf<ul> <li>capabilities</li> <li>commit</li> <li>delete_config</li> <li>discard</li> <li>edit_config</li> <li>get</li> <li>get_config</li> <li>lock</li> <li>rpc</li> <li>unlock</li> <li>validate</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/connection/","title":"connection","text":"<p>nornir_scrapli.connection</p>"},{"location":"reference/connection/#connection.ScrapliConfig","title":"<code>ScrapliConfig</code>","text":"<p>Scrapli connection plugin for nornir</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>class ScrapliConfig:\n\"\"\"Scrapli connection plugin for nornir\"\"\"\n\n    connection: ScrapliCfgPlatform\n\n    @staticmethod\n    def get_connection(task: Task) -&gt; ScrapliCfgPlatform:\n\"\"\"\n        Try to fetch scrapli-cfg conn, create it if it doesnt exist\n\n        This is a little different than \"normal\" in that we dont have a connection and we dont\n        create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and\n        wrap the scrapli_cfg bits around it.\n\n        Args:\n            task: nornir Task object\n\n        Returns:\n            ScrapliCfg\n\n        Raises:\n            N/A\n\n        \"\"\"\n        connection: ScrapliCfgPlatform\n\n        try:\n            connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config)\n        except AttributeError:\n            task.host.connections[\"scrapli_cfg\"] = ScrapliConfig.spawn(task=task)\n            connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config)\n\n        return connection\n\n    @staticmethod\n    def spawn(task: Task) -&gt; \"ConnectionPlugin\":\n\"\"\"\n        Spawn a ScrapliConfig object for a nornir host\n\n        This is a little different than \"normal\" in that we dont have a connection and we dont\n        create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and\n        wrap the scrapli_cfg bits around it.\n\n        Args:\n            task: nornir Task object\n\n        Returns:\n            ScrapliConfig\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n        scrapli_cfg_parameters = task.host.get_connection_parameters(connection=\"scrapli_cfg\")\n\n        # should always be a dict afaik, but typing doesnt appreciate the possibility it is None\n        extras = scrapli_cfg_parameters.extras or {}\n        # always overwrite `dedicated_connection` as we are *not* having a dedicated connection\n        # since we are wrapping the \"normal\" scrapli connection!\n        extras[\"dedicated_connection\"] = False\n\n        final_scrapli_cfg_parameters: Dict[str, Any] = {\n            \"conn\": scrapli_conn,\n            **extras,\n        }\n        connection = ScrapliCfg(**final_scrapli_cfg_parameters)\n        scrapli_config_connection_obj = ScrapliConfig()\n        scrapli_config_connection_obj.connection = connection\n        scrapli_config_connection_obj.open()\n        return scrapli_config_connection_obj\n\n    def open(self, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"\n        Override open method of normal nornir connection so we can coopt an existing conn\n\n        Args:\n            args: args for not dealing w/ overridden hings\n            kwargs: kwargs for not dealing w/ overridden hings\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        _, _ = args, kwargs\n        self.connection.prepare()\n\n    def close(self) -&gt; None:\n\"\"\"\n        Override close method of normal nornir connection so we never close things\n\n        Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliConfig.close","title":"<code>close() -&gt; None</code>","text":"<p>Override close method of normal nornir connection so we never close things</p> <p>Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Override close method of normal nornir connection so we never close things\n\n    Never closing allows us to not accidentally step on the underlying \"normal\" scrapli conn\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliConfig.get_connection","title":"<code>get_connection(task: Task) -&gt; ScrapliCfgPlatform</code>  <code>staticmethod</code>","text":"<p>Try to fetch scrapli-cfg conn, create it if it doesnt exist</p> <p>This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir Task object</p> required <p>Returns:</p> Type Description <code>ScrapliCfgPlatform</code> <p>ScrapliCfg</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>@staticmethod\ndef get_connection(task: Task) -&gt; ScrapliCfgPlatform:\n\"\"\"\n    Try to fetch scrapli-cfg conn, create it if it doesnt exist\n\n    This is a little different than \"normal\" in that we dont have a connection and we dont\n    create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and\n    wrap the scrapli_cfg bits around it.\n\n    Args:\n        task: nornir Task object\n\n    Returns:\n        ScrapliCfg\n\n    Raises:\n        N/A\n\n    \"\"\"\n    connection: ScrapliCfgPlatform\n\n    try:\n        connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config)\n    except AttributeError:\n        task.host.connections[\"scrapli_cfg\"] = ScrapliConfig.spawn(task=task)\n        connection = task.host.get_connection(\"scrapli_cfg\", task.nornir.config)\n\n    return connection\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliConfig.open","title":"<code>open(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Override open method of normal nornir connection so we can coopt an existing conn</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>args for not dealing w/ overridden hings</p> required <code>kwargs</code> <p>kwargs for not dealing w/ overridden hings</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>def open(self, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"\n    Override open method of normal nornir connection so we can coopt an existing conn\n\n    Args:\n        args: args for not dealing w/ overridden hings\n        kwargs: kwargs for not dealing w/ overridden hings\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    _, _ = args, kwargs\n    self.connection.prepare()\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliConfig.spawn","title":"<code>spawn(task: Task) -&gt; ConnectionPlugin</code>  <code>staticmethod</code>","text":"<p>Spawn a ScrapliConfig object for a nornir host</p> <p>This is a little different than \"normal\" in that we dont have a connection and we dont create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and wrap the scrapli_cfg bits around it.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir Task object</p> required <p>Returns:</p> Type Description <code>ConnectionPlugin</code> <p>ScrapliConfig</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>@staticmethod\ndef spawn(task: Task) -&gt; \"ConnectionPlugin\":\n\"\"\"\n    Spawn a ScrapliConfig object for a nornir host\n\n    This is a little different than \"normal\" in that we dont have a connection and we dont\n    create them in the \"normal\" nornir way -- we actually just steal the scrapli connection and\n    wrap the scrapli_cfg bits around it.\n\n    Args:\n        task: nornir Task object\n\n    Returns:\n        ScrapliConfig\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n    scrapli_cfg_parameters = task.host.get_connection_parameters(connection=\"scrapli_cfg\")\n\n    # should always be a dict afaik, but typing doesnt appreciate the possibility it is None\n    extras = scrapli_cfg_parameters.extras or {}\n    # always overwrite `dedicated_connection` as we are *not* having a dedicated connection\n    # since we are wrapping the \"normal\" scrapli connection!\n    extras[\"dedicated_connection\"] = False\n\n    final_scrapli_cfg_parameters: Dict[str, Any] = {\n        \"conn\": scrapli_conn,\n        **extras,\n    }\n    connection = ScrapliCfg(**final_scrapli_cfg_parameters)\n    scrapli_config_connection_obj = ScrapliConfig()\n    scrapli_config_connection_obj.connection = connection\n    scrapli_config_connection_obj.open()\n    return scrapli_config_connection_obj\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliCore","title":"<code>ScrapliCore</code>","text":"<p>Scrapli connection plugin for nornir</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>class ScrapliCore:\n\"\"\"Scrapli connection plugin for nornir\"\"\"\n\n    def open(\n        self,\n        hostname: Optional[str],\n        username: Optional[str],\n        password: Optional[str],\n        port: Optional[int],\n        platform: Optional[str],\n        extras: Optional[Dict[str, Any]] = None,\n        configuration: Optional[Config] = None,\n    ) -&gt; None:\n\"\"\"\n        Open a scrapli connection to a device\n\n        Args:\n            hostname: hostname from nornir inventory\n            username: username from nornir inventory/connection_options for scrapli\n            password: password from nornir inventory/connection_options for scrapli\n            port: port from nornir inventory/connection_options for scrapli\n            platform: platform from nornir inventory/connection_options for scrapli\n            extras: extras dict from connection_options for scrapli -- pass all other scrapli\n                arguments here\n            configuration: nornir configuration\n\n        Returns:\n            None\n\n        Raises:\n            NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform\n                string is provided\n\n        \"\"\"\n        extras = extras or {}\n        # 99.9% configuration will always be passed here... but to be consistent w/ the other\n        # plugins we'll leave the function signature same/same as the others\n        global_config = configuration.dict() if configuration else {}\n\n        parameters: Dict[str, Any] = {\n            \"host\": hostname,\n            \"auth_username\": username or \"\",\n            \"auth_password\": password or \"\",\n            \"port\": port or 22,\n            \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False),\n        }\n\n        # will override any of the configs from global nornir config (such as ssh config file) with\n        # options from \"extras\" (connection options)\n        parameters.update(extras)\n\n        if extras.get(\"channel_log\", False) is True:\n            # if channel_log value is just \"True\" we append the hostname so that we don't have a\n            # single file for potentially hundreds (or more!) of devices which obviously won't\n            # work very well. don't update the extras dict directly as that is probably coming from\n            # group/default vars, so just push this right onto the new parameters' dict.\n            parameters.update({\"channel_log\": f\"scrapli_channel_{hostname}.log\"})\n\n        if not platform:\n            raise NornirScrapliInvalidPlatform(\n                f\"'platform' not provided in inventory for host `{hostname}`\"\n            )\n\n        final_platform: str = PLATFORM_MAP.get(platform, platform)\n\n        if final_platform == \"generic\":\n            connection = GenericDriver(**parameters)\n        else:\n            try:\n                connection = Scrapli(**parameters, platform=final_platform)\n            except ScrapliModuleNotFound as exc:\n                raise NornirScrapliInvalidPlatform(\n                    f\"Provided platform `{final_platform}` is not a valid scrapli or napalm \"\n                    \"platform, or is not a valid scrapli-community platform.\"\n                ) from exc\n\n        connection.open()\n        self.connection = connection  # pylint: disable=W0201\n\n    def close(self) -&gt; None:\n\"\"\"\n        Close a scrapli connection to a device\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.connection.close()\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliCore.close","title":"<code>close() -&gt; None</code>","text":"<p>Close a scrapli connection to a device</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Close a scrapli connection to a device\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.connection.close()\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliCore.open","title":"<code>open(hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None) -&gt; None</code>","text":"<p>Open a scrapli connection to a device</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>Optional[str]</code> <p>hostname from nornir inventory</p> required <code>username</code> <code>Optional[str]</code> <p>username from nornir inventory/connection_options for scrapli</p> required <code>password</code> <code>Optional[str]</code> <p>password from nornir inventory/connection_options for scrapli</p> required <code>port</code> <code>Optional[int]</code> <p>port from nornir inventory/connection_options for scrapli</p> required <code>platform</code> <code>Optional[str]</code> <p>platform from nornir inventory/connection_options for scrapli</p> required <code>extras</code> <code>Optional[Dict[str, Any]]</code> <p>extras dict from connection_options for scrapli -- pass all other scrapli arguments here</p> <code>None</code> <code>configuration</code> <code>Optional[Config]</code> <p>nornir configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NornirScrapliInvalidPlatform</code> <p>if no platform or an invalid scrapli/napalm platform string is provided</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>def open(\n    self,\n    hostname: Optional[str],\n    username: Optional[str],\n    password: Optional[str],\n    port: Optional[int],\n    platform: Optional[str],\n    extras: Optional[Dict[str, Any]] = None,\n    configuration: Optional[Config] = None,\n) -&gt; None:\n\"\"\"\n    Open a scrapli connection to a device\n\n    Args:\n        hostname: hostname from nornir inventory\n        username: username from nornir inventory/connection_options for scrapli\n        password: password from nornir inventory/connection_options for scrapli\n        port: port from nornir inventory/connection_options for scrapli\n        platform: platform from nornir inventory/connection_options for scrapli\n        extras: extras dict from connection_options for scrapli -- pass all other scrapli\n            arguments here\n        configuration: nornir configuration\n\n    Returns:\n        None\n\n    Raises:\n        NornirScrapliInvalidPlatform: if no platform or an invalid scrapli/napalm platform\n            string is provided\n\n    \"\"\"\n    extras = extras or {}\n    # 99.9% configuration will always be passed here... but to be consistent w/ the other\n    # plugins we'll leave the function signature same/same as the others\n    global_config = configuration.dict() if configuration else {}\n\n    parameters: Dict[str, Any] = {\n        \"host\": hostname,\n        \"auth_username\": username or \"\",\n        \"auth_password\": password or \"\",\n        \"port\": port or 22,\n        \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False),\n    }\n\n    # will override any of the configs from global nornir config (such as ssh config file) with\n    # options from \"extras\" (connection options)\n    parameters.update(extras)\n\n    if extras.get(\"channel_log\", False) is True:\n        # if channel_log value is just \"True\" we append the hostname so that we don't have a\n        # single file for potentially hundreds (or more!) of devices which obviously won't\n        # work very well. don't update the extras dict directly as that is probably coming from\n        # group/default vars, so just push this right onto the new parameters' dict.\n        parameters.update({\"channel_log\": f\"scrapli_channel_{hostname}.log\"})\n\n    if not platform:\n        raise NornirScrapliInvalidPlatform(\n            f\"'platform' not provided in inventory for host `{hostname}`\"\n        )\n\n    final_platform: str = PLATFORM_MAP.get(platform, platform)\n\n    if final_platform == \"generic\":\n        connection = GenericDriver(**parameters)\n    else:\n        try:\n            connection = Scrapli(**parameters, platform=final_platform)\n        except ScrapliModuleNotFound as exc:\n            raise NornirScrapliInvalidPlatform(\n                f\"Provided platform `{final_platform}` is not a valid scrapli or napalm \"\n                \"platform, or is not a valid scrapli-community platform.\"\n            ) from exc\n\n    connection.open()\n    self.connection = connection  # pylint: disable=W0201\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliNetconf","title":"<code>ScrapliNetconf</code>","text":"<p>Scrapli NETCONF connection plugin for nornir</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>class ScrapliNetconf:\n\"\"\"Scrapli NETCONF connection plugin for nornir\"\"\"\n\n    def open(\n        self,\n        hostname: Optional[str],\n        username: Optional[str],\n        password: Optional[str],\n        port: Optional[int],\n        platform: Optional[str],\n        extras: Optional[Dict[str, Any]] = None,\n        configuration: Optional[Config] = None,\n    ) -&gt; None:\n\"\"\"\n        Open a scrapli connection to a device\n\n        Args:\n            hostname: hostname from nornir inventory\n            username: username from nornir inventory/connection_options for scrapli\n            password: password from nornir inventory/connection_options for scrapli\n            port: port from nornir inventory/connection_options for scrapli\n            platform: platform from nornir inventory/connection_options for scrapli; ignored with\n                scrapli netconf\n            extras: extras dict from connection_options for scrapli -- pass all other scrapli\n                arguments here\n            configuration: nornir configuration\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # platform is irrelevant for scrapli netconf for now\n        _ = platform\n        extras = extras or {}\n        # 99.9% configuration will always be passed here... but to be consistent w/ the other\n        # plugins we'll leave the function signature same/same as the others\n        global_config = configuration.dict() if configuration else {}\n\n        parameters: Dict[str, Any] = {\n            \"host\": hostname,\n            \"auth_username\": username or \"\",\n            \"auth_password\": password or \"\",\n            \"port\": port or 830,\n            \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False),\n        }\n\n        # will override any of the configs from global nornir config (such as ssh config file) with\n        # options from \"extras\" (connection options)\n        parameters.update(extras)\n\n        connection = NetconfDriver(**parameters)\n        connection.open()\n        self.connection = connection  # pylint: disable=W0201\n\n    def close(self) -&gt; None:\n\"\"\"\n        Close a scrapli netconf connection to a device\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.connection.close()\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliNetconf.close","title":"<code>close() -&gt; None</code>","text":"<p>Close a scrapli netconf connection to a device</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Close a scrapli netconf connection to a device\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.connection.close()\n</code></pre>"},{"location":"reference/connection/#connection.ScrapliNetconf.open","title":"<code>open(hostname: Optional[str], username: Optional[str], password: Optional[str], port: Optional[int], platform: Optional[str], extras: Optional[Dict[str, Any]] = None, configuration: Optional[Config] = None) -&gt; None</code>","text":"<p>Open a scrapli connection to a device</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>Optional[str]</code> <p>hostname from nornir inventory</p> required <code>username</code> <code>Optional[str]</code> <p>username from nornir inventory/connection_options for scrapli</p> required <code>password</code> <code>Optional[str]</code> <p>password from nornir inventory/connection_options for scrapli</p> required <code>port</code> <code>Optional[int]</code> <p>port from nornir inventory/connection_options for scrapli</p> required <code>platform</code> <code>Optional[str]</code> <p>platform from nornir inventory/connection_options for scrapli; ignored with scrapli netconf</p> required <code>extras</code> <code>Optional[Dict[str, Any]]</code> <p>extras dict from connection_options for scrapli -- pass all other scrapli arguments here</p> <code>None</code> <code>configuration</code> <code>Optional[Config]</code> <p>nornir configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>nornir_scrapli/connection.py</code> <pre><code>def open(\n    self,\n    hostname: Optional[str],\n    username: Optional[str],\n    password: Optional[str],\n    port: Optional[int],\n    platform: Optional[str],\n    extras: Optional[Dict[str, Any]] = None,\n    configuration: Optional[Config] = None,\n) -&gt; None:\n\"\"\"\n    Open a scrapli connection to a device\n\n    Args:\n        hostname: hostname from nornir inventory\n        username: username from nornir inventory/connection_options for scrapli\n        password: password from nornir inventory/connection_options for scrapli\n        port: port from nornir inventory/connection_options for scrapli\n        platform: platform from nornir inventory/connection_options for scrapli; ignored with\n            scrapli netconf\n        extras: extras dict from connection_options for scrapli -- pass all other scrapli\n            arguments here\n        configuration: nornir configuration\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # platform is irrelevant for scrapli netconf for now\n    _ = platform\n    extras = extras or {}\n    # 99.9% configuration will always be passed here... but to be consistent w/ the other\n    # plugins we'll leave the function signature same/same as the others\n    global_config = configuration.dict() if configuration else {}\n\n    parameters: Dict[str, Any] = {\n        \"host\": hostname,\n        \"auth_username\": username or \"\",\n        \"auth_password\": password or \"\",\n        \"port\": port or 830,\n        \"ssh_config_file\": global_config.get(\"ssh\", {}).get(\"config_file\", False),\n    }\n\n    # will override any of the configs from global nornir config (such as ssh config file) with\n    # options from \"extras\" (connection options)\n    parameters.update(extras)\n\n    connection = NetconfDriver(**parameters)\n    connection.open()\n    self.connection = connection  # pylint: disable=W0201\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":"<p>nornir_scrapli.exceptions</p>"},{"location":"reference/exceptions/#exceptions.NornirScrapliException","title":"<code>NornirScrapliException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>nornir_scrapli base exception</p> Source code in <code>nornir_scrapli/exceptions.py</code> <pre><code>class NornirScrapliException(Exception):\n\"\"\"nornir_scrapli base exception\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.NornirScrapliInvalidPlatform","title":"<code>NornirScrapliInvalidPlatform</code>","text":"<p>         Bases: <code>NornirScrapliException</code></p> <p>nornir_scrapli base exception</p> Source code in <code>nornir_scrapli/exceptions.py</code> <pre><code>class NornirScrapliInvalidPlatform(NornirScrapliException):\n\"\"\"nornir_scrapli base exception\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.NornirScrapliNoConfigModeGenericDriver","title":"<code>NornirScrapliNoConfigModeGenericDriver</code>","text":"<p>         Bases: <code>NornirScrapliException</code></p> <p>nornir_scrapli exception for attempting config mode on generic platform</p> Source code in <code>nornir_scrapli/exceptions.py</code> <pre><code>class NornirScrapliNoConfigModeGenericDriver(NornirScrapliException):\n\"\"\"nornir_scrapli exception for attempting config mode on generic platform\"\"\"\n</code></pre>"},{"location":"reference/helper/","title":"helper","text":"<p>nornir_scrapli.helper</p>"},{"location":"reference/helper/#helper.diff_xml_text","title":"<code>diff_xml_text(document_one: str, document_two: str) -&gt; str</code>","text":"<p>Diff xml text strings</p> <p>Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is really pretty simple and not always super great, but better than nothing for now!</p> <p>Parameters:</p> Name Type Description Default <code>document_one</code> <code>str</code> <p>string of xml doc 1</p> required <code>document_two</code> <code>str</code> <p>string of xml doc 2</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>unified diff of the two input documents</p> Source code in <code>nornir_scrapli/helper.py</code> <pre><code>def diff_xml_text(document_one: str, document_two: str) -&gt; str:\n\"\"\"\n    Diff xml text strings\n\n    Really could be just \"diff text\" but also ensuring we ignore the \"message-id\" lines. This is\n    really pretty simple and not always super great, but better than nothing for now!\n\n    Args:\n        document_one: string of xml doc 1\n        document_two: string of xml doc 2\n\n    Returns:\n        str: unified diff of the two input documents\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # ignore message-id stuff -- maybe more in the future?\n    document_one_lines = [line for line in document_one.splitlines() if \"message-id\" not in line]\n    document_two_lines = [line for line in document_two.splitlines() if \"message-id\" not in line]\n    diff = difflib.unified_diff(document_one_lines, document_two_lines)\n\n    diff_lines = []\n    for line in diff:\n        if line.startswith(\"---\") or line.startswith(\"+++\"):\n            # may as well just strip out the header lines and such, we dont care about them\n            continue\n        if line.startswith(\"+\"):\n            diff_lines.append(f\"{ANSI_GREEN}{line}{ANSI_END}\")\n        elif line.startswith(\"-\"):\n            diff_lines.append(f\"{ANSI_RED}{line}{ANSI_END}\")\n        else:\n            diff_lines.append(line)\n\n    return \"\\n\".join(diff_lines)\n</code></pre>"},{"location":"reference/result/","title":"result","text":"<p>nornir_scrapli.result</p>"},{"location":"reference/result/#result.ScrapliResult","title":"<code>ScrapliResult</code>","text":"<p>         Bases: <code>Result</code></p> Source code in <code>nornir_scrapli/result.py</code> <pre><code>class ScrapliResult(Result):\n    def __init__(\n        self,\n        host: \"Host\",\n        result: Optional[str],\n        scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] = None,\n        changed: bool = False,\n        **kwargs: Any,\n    ):\n\"\"\"\n        Scrapli Nornir Result object\n\n        A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses\n        the original response object returned from scrapli\n\n        Args:\n            host: nornir task host object\n            result: result text returned from scrapli task\n            scrapli_response: original response object returned from scrapli task\n            changed: bool indicating if a change has occurred\n            kwargs: keyword arguments to pass to nornir Result\n\n        Returns:\n            N/A  # noqa: DAR202\n\n        Raises:\n            N/A\n\n        \"\"\"\n        failed = self._process_failed(scrapli_response=scrapli_response)\n\n        super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs)\n\n        self.scrapli_response = scrapli_response\n\n    @staticmethod\n    def _process_failed(\n        scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]]\n    ) -&gt; bool:\n\"\"\"\n        Process and return string of scrapli response(s)\n\n        Args:\n            scrapli_response: scrapli Response or MultiResponse object\n\n        Returns:\n            bool: bool indicating if the nornir task failed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if scrapli_response is None:\n            return False\n        if isinstance(scrapli_response, (Response, ScrapliCfgResponse)):\n            failed: bool = scrapli_response.failed\n            return failed\n        if any(response.failed for response in scrapli_response):\n            return True\n        return False\n</code></pre>"},{"location":"reference/result/#result.ScrapliResult.__init__","title":"<code>__init__(host: Host, result: Optional[str], scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] = None, changed: bool = False, **kwargs: Any)</code>","text":"<p>Scrapli Nornir Result object</p> <p>A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses the original response object returned from scrapli</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Host</code> <p>nornir task host object</p> required <code>result</code> <code>Optional[str]</code> <p>result text returned from scrapli task</p> required <code>scrapli_response</code> <code>Optional[Union[Response, MultiResponse, ScrapliCfgResponse]]</code> <p>original response object returned from scrapli task</p> <code>None</code> <code>changed</code> <code>bool</code> <p>bool indicating if a change has occurred</p> <code>False</code> <code>kwargs</code> <p>keyword arguments to pass to nornir Result</p> required <p>Returns:</p> Type Description <p>N/A  # noqa: DAR202</p> Source code in <code>nornir_scrapli/result.py</code> <pre><code>def __init__(\n    self,\n    host: \"Host\",\n    result: Optional[str],\n    scrapli_response: Optional[Union[Response, MultiResponse, ScrapliCfgResponse]] = None,\n    changed: bool = False,\n    **kwargs: Any,\n):\n\"\"\"\n    Scrapli Nornir Result object\n\n    A \"normal\" nornir result object with an additional attribute \"scrapli_response\" which houses\n    the original response object returned from scrapli\n\n    Args:\n        host: nornir task host object\n        result: result text returned from scrapli task\n        scrapli_response: original response object returned from scrapli task\n        changed: bool indicating if a change has occurred\n        kwargs: keyword arguments to pass to nornir Result\n\n    Returns:\n        N/A  # noqa: DAR202\n\n    Raises:\n        N/A\n\n    \"\"\"\n    failed = self._process_failed(scrapli_response=scrapli_response)\n\n    super().__init__(host=host, result=result, failed=failed, changed=changed, **kwargs)\n\n    self.scrapli_response = scrapli_response\n</code></pre>"},{"location":"reference/result/#result.process_command_result","title":"<code>process_command_result(scrapli_response: Union[Response, MultiResponse]) -&gt; str</code>","text":"<p>Process and return string of scrapli response(s)</p> <p>Parameters:</p> Name Type Description Default <code>scrapli_response</code> <code>Union[Response, MultiResponse]</code> <p>scrapli Response or MultiResponse object</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string result from nornir task or None</p> Source code in <code>nornir_scrapli/result.py</code> <pre><code>def process_command_result(scrapli_response: Union[Response, MultiResponse]) -&gt; str:\n\"\"\"\n    Process and return string of scrapli response(s)\n\n    Args:\n        scrapli_response: scrapli Response or MultiResponse object\n\n    Returns:\n        str: string result from nornir task or None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if isinstance(scrapli_response, Response):\n        result: str = scrapli_response.result\n        return result\n    return \"\\n\\n\".join([response.result for response in scrapli_response])\n</code></pre>"},{"location":"reference/result/#result.process_config_result","title":"<code>process_config_result(scrapli_response: Union[Response, MultiResponse]) -&gt; str</code>","text":"<p>Process and return string of scrapli response(s)</p> <p>Parameters:</p> Name Type Description Default <code>scrapli_response</code> <code>Union[Response, MultiResponse]</code> <p>scrapli Response or MultiResponse object</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string result from nornir task or None</p> Source code in <code>nornir_scrapli/result.py</code> <pre><code>def process_config_result(scrapli_response: Union[Response, MultiResponse]) -&gt; str:\n\"\"\"\n    Process and return string of scrapli response(s)\n\n    Args:\n        scrapli_response: scrapli Response or MultiResponse object\n\n    Returns:\n        str: string result from nornir task or None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    full_results = \"\"\n    if isinstance(scrapli_response, Response):\n        for config_input, config_result in zip(\n            scrapli_response.channel_input.split(\"\\n\"), scrapli_response.result.split(\"\\n\")\n        ):\n            if config_input == config_result:\n                full_results += f\"{config_input}\\n\"\n            else:\n                full_results += \"\\n\".join([config_input, config_result])\n    else:\n        for response in scrapli_response:\n            full_results += \"\\n\".join([response.channel_input, response.result])\n    return full_results\n</code></pre>"},{"location":"reference/functions/","title":"functions","text":"<p>nornir_scrapli.functions</p>"},{"location":"reference/functions/print_structured_result/","title":"print_structured_result","text":"<p>nornir_scrapli.functions.print_structured_result</p>"},{"location":"reference/functions/print_structured_result/#functions.print_structured_result.print_structured_result","title":"<code>print_structured_result(result: AggregatedResult, failed: bool = False, severity_level: int = logging.INFO, parser: str = 'textfsm', to_dict: bool = True, fail_to_string: bool = False) -&gt; None</code>","text":"<p>Prints the :obj:<code>nornir.core.task.Result</code> from a previous task to screen</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>AggregatedResult</code> <p>Nornir AggregateResult object from a previous task</p> required <code>failed</code> <code>bool</code> <p>if <code>True</code> assume the task failed</p> <code>False</code> <code>severity_level</code> <code>int</code> <p>Print only errors with this severity level or higher</p> <code>logging.INFO</code> <code>parser</code> <code>str</code> <p>textfsm|genie -- parser to parse output with</p> <code>'textfsm'</code> <code>to_dict</code> <code>bool</code> <p>output structured data in dict form instead -- basically put k:v instead of just lists of lists of values for textfsm output; ignored if parser == \"genie\"</p> <code>True</code> <code>fail_to_string</code> <code>bool</code> <p>fallback to printing unstructured output or have tasks skipped (because print_result won't print empty lists which scrapli returns if parsing fails)</p> <code>False</code> Source code in <code>functions/print_structured_result.py</code> <pre><code>def print_structured_result(\n    result: AggregatedResult,\n    failed: bool = False,\n    severity_level: int = logging.INFO,\n    parser: str = \"textfsm\",\n    to_dict: bool = True,\n    fail_to_string: bool = False,\n) -&gt; None:\n\"\"\"\n    Prints the :obj:`nornir.core.task.Result` from a previous task to screen\n\n    Arguments:\n        result: Nornir AggregateResult object from a previous task\n        failed: if `True` assume the task failed\n        severity_level: Print only errors with this severity level or higher\n        parser: textfsm|genie -- parser to parse output with\n        to_dict: output structured data in dict form instead -- basically put k:v instead of just\n            lists of lists of values for textfsm output; ignored if parser == \"genie\"\n        fail_to_string: fallback to printing unstructured output or have tasks skipped (because\n            print_result won't print empty lists which scrapli returns if parsing fails)\n\n    \"\"\"\n    updated_agg_result = AggregatedResult(result.name)\n    for hostname, multi_result in result.items():\n        updated_multi_result = MultiResult(result.name)\n        for individual_result in multi_result:\n            scrapli_responses = getattr(individual_result, \"scrapli_response\", None)\n            if isinstance(scrapli_responses, Response):\n                scrapli_responses = [scrapli_responses]\n            if not scrapli_responses:\n                updated_multi_result.append(individual_result)\n                continue\n            for scrapli_response in scrapli_responses:\n                parser_method = getattr(scrapli_response, f\"{parser}_parse_output\")\n                updated_result = Result(\n                    host=individual_result.host,\n                    changed=individual_result.changed,\n                    diff=individual_result.diff,\n                    exception=individual_result.exception,\n                    failed=individual_result.failed,\n                    name=individual_result.name,\n                    severity_level=individual_result.severity_level,\n                    stderr=individual_result.stderr,\n                    stdout=individual_result.stdout,\n                )\n\n                if parser == \"textfsm\":\n                    structured_result = parser_method(to_dict=to_dict)\n                else:\n                    structured_result = parser_method()\n\n                if not structured_result and fail_to_string:\n                    updated_result.result = scrapli_response.result\n                else:\n                    updated_result.result = structured_result\n                updated_multi_result.append(updated_result)\n        if updated_multi_result:\n            updated_agg_result[hostname] = updated_multi_result  # noqa\n\n    LOCK.acquire()  # pylint: disable=R1732\n    try:\n        _print_result(\n            result=updated_agg_result, attrs=None, failed=failed, severity_level=severity_level\n        )\n    finally:\n        LOCK.release()\n</code></pre>"},{"location":"reference/tasks/","title":"tasks","text":"<p>nornir_scrapli.tasks</p>"},{"location":"reference/tasks/cfg/","title":"cfg","text":"<p>nornir_scrapli.tasks.cfg</p>"},{"location":"reference/tasks/cfg/abort_config/","title":"abort_config","text":"<p>nornir_scrapli.tasks.cfg_abort_config</p>"},{"location":"reference/tasks/cfg/abort_config/#tasks.cfg.abort_config.cfg_abort_config","title":"<code>cfg_abort_config(task: Task) -&gt; Result</code>","text":"<p>Abort a device candidate config with scrapli-cfg</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the load_config operation</p> Source code in <code>tasks/cfg/abort_config.py</code> <pre><code>def cfg_abort_config(task: Task) -&gt; Result:\n\"\"\"\n    Abort a device candidate config with scrapli-cfg\n\n    Args:\n        task: nornir task object\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            load_config operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_cfg_conn = ScrapliConfig.get_connection(task=task)\n\n    scrapli_response = scrapli_cfg_conn.abort_config()\n\n    result = ScrapliResult(\n        host=task.host,\n        result=scrapli_response.result,\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/tasks/cfg/commit_config/","title":"commit_config","text":"<p>nornir_scrapli.tasks.cfg_commit_config</p>"},{"location":"reference/tasks/cfg/commit_config/#tasks.cfg.commit_config.cfg_commit_config","title":"<code>cfg_commit_config(task: Task, source: str = 'running') -&gt; Result</code>","text":"<p>Commit a device candidate config with scrapli-cfg</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>source</code> <code>str</code> <p>name of the config source to commit against, generally running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the load_config operation</p> Source code in <code>tasks/cfg/commit_config.py</code> <pre><code>def cfg_commit_config(task: Task, source: str = \"running\") -&gt; Result:\n\"\"\"\n    Commit a device candidate config with scrapli-cfg\n\n    Args:\n        task: nornir task object\n        source: name of the config source to commit against, generally running|startup\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            load_config operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_cfg_conn = ScrapliConfig.get_connection(task=task)\n\n    scrapli_response = scrapli_cfg_conn.commit_config(source=source)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=scrapli_response.result,\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/tasks/cfg/diff_config/","title":"diff_config","text":"<p>nornir_scrapli.tasks.cfg_diff_config</p>"},{"location":"reference/tasks/cfg/diff_config/#tasks.cfg.diff_config.cfg_diff_config","title":"<code>cfg_diff_config(task: Task, source: str = 'running') -&gt; Result</code>","text":"<p>Diff a device candidate config vs a source config with scrapli-cfg</p> <p>The \"device diff\" is stored as the result. You can access the side by side or unified scrapli cfg diffs via the \"scrapli_response\" object stored in the result!</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>source</code> <code>str</code> <p>name of the config source to commit against, generally running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the load_config operation</p> Source code in <code>tasks/cfg/diff_config.py</code> <pre><code>def cfg_diff_config(task: Task, source: str = \"running\") -&gt; Result:\n\"\"\"\n    Diff a device candidate config vs a source config with scrapli-cfg\n\n    The \"device diff\" is stored as the result. You can access the side by side or unified scrapli\n    cfg diffs via the \"scrapli_response\" object stored in the result!\n\n    Args:\n        task: nornir task object\n        source: name of the config source to commit against, generally running|startup\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            load_config operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_cfg_conn = ScrapliConfig.get_connection(task=task)\n\n    scrapli_response = scrapli_cfg_conn.diff_config(source=source)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=scrapli_response.device_diff,\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/tasks/cfg/get_config/","title":"get_config","text":"<p>nornir_scrapli.tasks.cfg_get_config</p>"},{"location":"reference/tasks/cfg/get_config/#tasks.cfg.get_config.cfg_get_config","title":"<code>cfg_get_config(task: Task, source: str = 'running') -&gt; Result</code>","text":"<p>Get device config with scrapli-cfg</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>source</code> <code>str</code> <p>config source to get</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to current prompt</p> Source code in <code>tasks/cfg/get_config.py</code> <pre><code>def cfg_get_config(task: Task, source: str = \"running\") -&gt; Result:\n\"\"\"\n    Get device config with scrapli-cfg\n\n    Args:\n        task: nornir task object\n        source: config source to get\n\n    Returns:\n        Result: nornir result object with Result.result value set to current prompt\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_cfg_conn = ScrapliConfig.get_connection(task=task)\n\n    scrapli_response = scrapli_cfg_conn.get_config(source=source)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=scrapli_response.result,\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/tasks/cfg/get_version/","title":"get_version","text":"<p>nornir_scrapli.tasks.cfg.get_version</p>"},{"location":"reference/tasks/cfg/get_version/#tasks.cfg.get_version.cfg_get_version","title":"<code>cfg_get_version(task: Task) -&gt; Result</code>","text":"<p>Get device version with scrapli-cfg</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to current version of device</p> Source code in <code>tasks/cfg/get_version.py</code> <pre><code>def cfg_get_version(task: Task) -&gt; Result:\n\"\"\"\n    Get device version with scrapli-cfg\n\n    Args:\n        task: nornir task object\n\n    Returns:\n        Result: nornir result object with Result.result value set to current version of device\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_cfg_conn = ScrapliConfig.get_connection(task=task)\n\n    version = scrapli_cfg_conn.get_version()\n\n    return Result(host=task.host, result=version.result, failed=False, changed=False)\n</code></pre>"},{"location":"reference/tasks/cfg/load_config/","title":"load_config","text":"<p>nornir_scrapli.tasks.cfg_load_config</p>"},{"location":"reference/tasks/cfg/load_config/#tasks.cfg.load_config.cfg_load_config","title":"<code>cfg_load_config(task: Task, config: str, replace: bool = False, **kwargs: Any) -&gt; Result</code>","text":"<p>Load device config with scrapli-cfg</p> <p>Note that <code>changed</code> will still be <code>False</code> because this is just loading a candidate config!</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see your specific platform for details</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the load_config operation</p> Source code in <code>tasks/cfg/load_config.py</code> <pre><code>def cfg_load_config(task: Task, config: str, replace: bool = False, **kwargs: Any) -&gt; Result:\n\"\"\"\n    Load device config with scrapli-cfg\n\n    Note that `changed` will still be `False` because this is just loading a candidate config!\n\n    Args:\n        task: nornir task object\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see your specific platform for details\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            load_config operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_cfg_conn = ScrapliConfig.get_connection(task=task)\n\n    scrapli_response = scrapli_cfg_conn.load_config(config=config, replace=replace, **kwargs)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=scrapli_response.result,\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/tasks/core/","title":"core","text":"<p>nornir_scrapli.tasks.core</p>"},{"location":"reference/tasks/core/get_prompt/","title":"get_prompt","text":"<p>nornir_scrapli.tasks.get_prompt</p>"},{"location":"reference/tasks/core/get_prompt/#tasks.core.get_prompt.get_prompt","title":"<code>get_prompt(task: Task) -&gt; Result</code>","text":"<p>Get current prompt from device using scrapli</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to current prompt</p> Source code in <code>tasks/core/get_prompt.py</code> <pre><code>def get_prompt(task: Task) -&gt; Result:\n\"\"\"\n    Get current prompt from device using scrapli\n\n    Args:\n        task: nornir task object\n\n    Returns:\n        Result: nornir result object with Result.result value set to current prompt\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n    prompt = scrapli_conn.get_prompt()\n    return Result(host=task.host, result=prompt, failed=False, changed=False)\n</code></pre>"},{"location":"reference/tasks/core/send_command/","title":"send_command","text":"<p>nornir_scrapli.tasks.send_command</p>"},{"location":"reference/tasks/core/send_command/#tasks.core.send_command.send_command","title":"<code>send_command(task: Task, command: str, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, timeout_ops: Optional[float] = None) -&gt; Result</code>","text":"<p>Send a single command to device using scrapli</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>command</code> <code>str</code> <p>string to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>scrapli nornir result object; almost identical to a \"normal\" nornir result object, but contains an additional attribute \"scrapli_response\" that contains the original response from scrapli</p> Source code in <code>tasks/core/send_command.py</code> <pre><code>def send_command(\n    task: Task,\n    command: str,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    timeout_ops: Optional[float] = None,\n) -&gt; Result:\n\"\"\"\n    Send a single command to device using scrapli\n\n    Args:\n        task: nornir task object\n        command: string to send to device in privilege exec mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n\n    Returns:\n        Result: scrapli nornir result object; almost identical to a \"normal\" nornir result object,\n            but contains an additional attribute \"scrapli_response\" that contains the original\n            response from scrapli\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n    scrapli_response = scrapli_conn.send_command(\n        command=command,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        timeout_ops=timeout_ops,\n    )\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/core/send_commands/","title":"send_commands","text":"<p>nornir_scrapli.tasks.send_commands</p>"},{"location":"reference/tasks/core/send_commands/#tasks.core.send_commands.send_commands","title":"<code>send_commands(task: Task, commands: List[str], strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; Result</code>","text":"<p>Send a list of commands to device using scrapli</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>commands</code> <code>List[str]</code> <p>list of strings to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to returned scrapli Response object</p> Source code in <code>tasks/core/send_commands.py</code> <pre><code>def send_commands(\n    task: Task,\n    commands: List[str],\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; Result:\n\"\"\"\n    Send a list of commands to device using scrapli\n\n    Args:\n        task: nornir task object\n        commands: list of strings to send to device in privilege exec mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results as of\n            current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        Result: nornir result object with Result.result value set to returned scrapli Response\n            object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n    scrapli_response = scrapli_conn.send_commands(\n        commands=commands,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/core/send_commands_from_file/","title":"send_commands_from_file","text":"<p>nornir_scrapli.tasks.send_commands</p>"},{"location":"reference/tasks/core/send_commands_from_file/#tasks.core.send_commands_from_file.send_commands_from_file","title":"<code>send_commands_from_file(task: Task, file: str, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; Result</code>","text":"<p>Send a list of commands from a file to device using scrapli</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>file</code> <code>str</code> <p>string path to file</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to returned scrapli Response object</p> Source code in <code>tasks/core/send_commands_from_file.py</code> <pre><code>def send_commands_from_file(\n    task: Task,\n    file: str,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; Result:\n\"\"\"\n    Send a list of commands from a file to device using scrapli\n\n    Args:\n        task: nornir task object\n        file: string path to file\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results as of\n            current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n\n    Returns:\n        Result: nornir result object with Result.result value set to returned scrapli Response\n            object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n    scrapli_response = scrapli_conn.send_commands_from_file(\n        file=file,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/core/send_config/","title":"send_config","text":"<p>nornir_scrapli.tasks.send_config</p>"},{"location":"reference/tasks/core/send_config/#tasks.core.send_config.send_config","title":"<code>send_config(task: Task, config: str, dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; Result</code>","text":"<p>Send a config to device using scrapli</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>config</code> <code>str</code> <p>string configuration to send to the device, supports sending multi-line strings</p> required <code>dry_run</code> <code>Optional[bool]</code> <p>Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs</p> <code>None</code> <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the  channel. Do not use this unless you know what you are doing as it is possible that  it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to returned scrapli Response object</p> <p>Raises:</p> Type Description <code>NornirScrapliNoConfigModeGenericDriver</code> <p>If attempting to use this task function against a host that is using the \"generic\" platform type</p> Source code in <code>tasks/core/send_config.py</code> <pre><code>def send_config(\n    task: Task,\n    config: str,\n    dry_run: Optional[bool] = None,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; Result:\n\"\"\"\n    Send a config to device using scrapli\n\n    Args:\n        task: nornir task object\n        config: string configuration to send to the device, supports sending multi-line strings\n        dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to\n            enter config mode, but will NOT send any configs\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results as of\n            current execution\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n            JunosDriver. You can also pass in a name of a configuration session such as\n            \"my-config-session\" if you have registered a session using the\n            \"register_config_session\" method of the EOSDriver or NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n             channel. Do *not* use this unless you know what you are doing as it is possible that\n             it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        Result: nornir result object with Result.result value set to returned scrapli Response\n            object\n\n    Raises:\n        NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a\n            host that is using the \"generic\" platform type\n\n    \"\"\"\n    if task.host.platform == \"generic\":\n        raise NornirScrapliNoConfigModeGenericDriver(\"No config mode for 'generic' platform type\")\n\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n\n    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run\n\n    if _task_dry_run:\n        # if dry run, try to acquire config mode then back out; do not send any configurations!\n        scrapli_conn.acquire_priv(\"configuration\")\n        scrapli_conn.acquire_priv(scrapli_conn.default_desired_privilege_level)\n        return ScrapliResult(host=task.host, result=None, scrapli_response=None, changed=False)\n\n    scrapli_response = scrapli_conn.send_config(\n        config=config,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        privilege_level=privilege_level,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_config_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/core/send_configs/","title":"send_configs","text":"<p>nornir_scrapli.tasks.send_configs</p>"},{"location":"reference/tasks/core/send_configs/#tasks.core.send_configs.send_configs","title":"<code>send_configs(task: Task, configs: List[str], dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; Result</code>","text":"<p>Send configs to device using scrapli</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>configs</code> <code>List[str]</code> <p>list of strings to send to device in config mode</p> required <code>dry_run</code> <code>Optional[bool]</code> <p>Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs</p> <code>None</code> <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to returned scrapli Response object</p> <p>Raises:</p> Type Description <code>NornirScrapliNoConfigModeGenericDriver</code> <p>If attempting to use this task function against a host that is using the \"generic\" platform type</p> Source code in <code>tasks/core/send_configs.py</code> <pre><code>def send_configs(\n    task: Task,\n    configs: List[str],\n    dry_run: Optional[bool] = None,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; Result:\n\"\"\"\n    Send configs to device using scrapli\n\n    Args:\n        task: nornir task object\n        configs: list of strings to send to device in config mode\n        dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to\n            enter config mode, but will NOT send any configs\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results as of\n            current execution\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n            JunosDriver. You can also pass in a name of a configuration session such as\n            \"my-config-session\" if you have registered a session using the\n            \"register_config_session\" method of the EOSDriver or NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        Result: nornir result object with Result.result value set to returned scrapli Response\n            object\n\n    Raises:\n        NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a\n            host that is using the \"generic\" platform type\n\n    \"\"\"\n    if task.host.platform == \"generic\":\n        raise NornirScrapliNoConfigModeGenericDriver(\"No config mode for 'generic' platform type\")\n\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n\n    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run\n\n    if _task_dry_run:\n        # if dry run, try to acquire config mode then back out; do not send any configurations!\n        scrapli_conn.acquire_priv(\"configuration\")\n        scrapli_conn.acquire_priv(scrapli_conn.default_desired_privilege_level)\n        return ScrapliResult(host=task.host, result=None, scrapli_response=None, changed=False)\n\n    scrapli_response = scrapli_conn.send_configs(\n        configs=configs,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        privilege_level=privilege_level,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_config_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/core/send_configs_from_file/","title":"send_configs_from_file","text":"<p>nornir_scrapli.tasks.send_configs_from_file</p>"},{"location":"reference/tasks/core/send_configs_from_file/#tasks.core.send_configs_from_file.send_configs_from_file","title":"<code>send_configs_from_file(task: Task, file: str, dry_run: Optional[bool] = None, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; Result</code>","text":"<p>Send configs from a file to device using scrapli</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>file</code> <code>str</code> <p>string path to file</p> required <code>dry_run</code> <code>Optional[bool]</code> <p>Whether to apply changes or not; if dry run, will ensure that it is possible to enter config mode, but will NOT send any configs</p> <code>None</code> <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to returned scrapli Response object</p> <p>Raises:</p> Type Description <code>NornirScrapliNoConfigModeGenericDriver</code> <p>If attempting to use this task function against a host that is using the \"generic\" platform type</p> Source code in <code>tasks/core/send_configs_from_file.py</code> <pre><code>def send_configs_from_file(\n    task: Task,\n    file: str,\n    dry_run: Optional[bool] = None,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; Result:\n\"\"\"\n    Send configs from a file to device using scrapli\n\n    Args:\n        task: nornir task object\n        file: string path to file\n        dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to\n            enter config mode, but will NOT send any configs\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results as of\n            current execution\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n            JunosDriver. You can also pass in a name of a configuration session such as\n            \"my-config-session\" if you have registered a session using the\n            \"register_config_session\" method of the EOSDriver or NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        Result: nornir result object with Result.result value set to returned scrapli Response\n            object\n\n    Raises:\n        NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a\n            host that is using the \"generic\" platform type\n\n    \"\"\"\n    if task.host.platform == \"generic\":\n        raise NornirScrapliNoConfigModeGenericDriver(\"No config mode for 'generic' platform type\")\n\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n\n    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run\n\n    if _task_dry_run:\n        # if dry run, try to acquire config mode then back out; do not send any configurations!\n        scrapli_conn.acquire_priv(\"configuration\")\n        scrapli_conn.acquire_priv(scrapli_conn.default_desired_privilege_level)\n        return ScrapliResult(host=task.host, result=None, scrapli_response=None, changed=False)\n\n    scrapli_response = scrapli_conn.send_configs_from_file(\n        file=file,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        privilege_level=privilege_level,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_config_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/core/send_interactive/","title":"send_interactive","text":"<p>nornir_scrapli.tasks.send_interactive</p>"},{"location":"reference/tasks/core/send_interactive/#tasks.core.send_interactive.send_interactive","title":"<code>send_interactive(task: Task, interact_events: List[Tuple[str, str, Optional[bool]]], failed_when_contains: Optional[Union[str, List[str]]] = None, privilege_level: str = '', timeout_ops: Optional[float] = None) -&gt; Result</code>","text":"<p>Send inputs in an interactive fashion using scrapli; usually used to handle prompts</p> <p>Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input) An example where we need this sort of capability:</p> <pre><code>3560CX#copy flash: scp:\nSource filename []? test1.txt\nAddress or name of remote host []? 172.31.254.100\nDestination username [carl]?\nWriting test1.txt\nPassword:\nPassword:\n Sink: C0644 639 test1.txt\n!\n639 bytes copied in 12.066 secs (53 bytes/sec)\n3560CX#\n</code></pre> <p>To accomplish this we can use the following (in \"native\" scrapli):</p> <pre><code>interact = conn.channel.send_inputs_interact(\n    [\n        (\"copy flash: scp:\", \"Source filename []?\", False),\n        (\"test1.txt\", \"Address or name of remote host []?\", False),\n        (\"172.31.254.100\", \"Destination username [carl]?\", False),\n        (\"carl\", \"Password:\", False),\n        (\"super_secure_password\", prompt, True),\n    ]\n)\n</code></pre> <p>If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\".</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>interact_events</code> <code>List[Tuple[str, str, Optional[bool]]]</code> <p>list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden)</p> required <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>list of strings that, if present in final output, represent a failed command/interaction</p> <code>None</code> <code>privilege_level</code> <code>str</code> <p>name of the privilege level to operate in</p> <code>''</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to returned scrapli Response object</p> Source code in <code>tasks/core/send_interactive.py</code> <pre><code>def send_interactive(\n    task: Task,\n    interact_events: List[Tuple[str, str, Optional[bool]]],\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    privilege_level: str = \"\",\n    timeout_ops: Optional[float] = None,\n) -&gt; Result:\n\"\"\"\n    Send inputs in an interactive fashion using scrapli; usually used to handle prompts\n\n    Used to interact with devices where prompts change per input, and where inputs may be hidden\n    such as in the case of a password input. This can be used to respond to challenges from\n    devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n    example. You may have as many elements in the \"interact_events\" list as needed, and each\n    element of that list should be a tuple of two or three elements. The first element is always\n    the input to send as a string, the second should be the expected response as a string, and\n    the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n    An example where we need this sort of capability:\n\n    ```\n    3560CX#copy flash: scp:\n    Source filename []? test1.txt\n    Address or name of remote host []? 172.31.254.100\n    Destination username [carl]?\n    Writing test1.txt\n    Password:\n    Password:\n     Sink: C0644 639 test1.txt\n    !\n    639 bytes copied in 12.066 secs (53 bytes/sec)\n    3560CX#\n    ```\n\n    To accomplish this we can use the following (in \"native\" scrapli):\n\n    ```\n    interact = conn.channel.send_inputs_interact(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"test1.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"carl\", \"Password:\", False),\n            (\"super_secure_password\", prompt, True),\n        ]\n    )\n    ```\n\n    If we needed to deal with more prompts we could simply continue adding tuples to the list of\n    interact \"events\".\n\n    Args:\n        task: nornir task object\n        interact_events: list of tuples containing the \"interactions\" with the device\n            each list element must have an input and an expected response, and may have an\n            optional bool for the third and final element -- the optional bool specifies if the\n            input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n            not provided it is assumed the input is \"normal\" (not hidden)\n        failed_when_contains: list of strings that, if present in final output, represent a\n            failed command/interaction\n        privilege_level: name of the privilege level to operate in\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n\n    Returns:\n        Result: nornir result object with Result.result value set to returned scrapli Response\n            object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli\", task.nornir.config)\n    scrapli_response = scrapli_conn.send_interactive(\n        interact_events=interact_events,\n        failed_when_contains=failed_when_contains,\n        privilege_level=privilege_level,\n        timeout_ops=timeout_ops,\n    )\n\n    result = Result(\n        host=task.host,\n        result=scrapli_response,\n        failed=scrapli_response.failed,\n        changed=True,\n    )\n    setattr(result, \"scrapli_response\", scrapli_response)\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/","title":"netconf","text":"<p>nornir_scrapli.tasks.netconf</p>"},{"location":"reference/tasks/netconf/capabilities/","title":"capabilities","text":"<p>nornir_scrapli.tasks.netconf_capabilities</p>"},{"location":"reference/tasks/netconf/capabilities/#tasks.netconf.capabilities.netconf_capabilities","title":"<code>netconf_capabilities(task: Task) -&gt; Result</code>","text":"<p>Retrieve the device config with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set to a list of strings representing the device capabilities</p> Source code in <code>tasks/netconf/capabilities.py</code> <pre><code>def netconf_capabilities(\n    task: Task,\n) -&gt; Result:\n\"\"\"\n    Retrieve the device config with scrapli_netconf\n\n    Args:\n        task: nornir task object\n\n    Returns:\n        Result: nornir result object with Result.result value set to a list of strings representing\n            the device capabilities\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n\n    result = Result(\n        host=task.host,\n        result=scrapli_conn.server_capabilities,\n        failed=False,\n        changed=False,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/commit/","title":"commit","text":"<p>nornir_scrapli.tasks.netconf_commit</p>"},{"location":"reference/tasks/netconf/commit/#tasks.netconf.commit.netconf_commit","title":"<code>netconf_commit(task: Task) -&gt; Result</code>","text":"<p>Commit the device config with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get operation</p> Source code in <code>tasks/netconf/commit.py</code> <pre><code>def netconf_commit(\n    task: Task,\n) -&gt; Result:\n\"\"\"\n    Commit the device config with scrapli_netconf\n\n    Args:\n        task: nornir task object\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.commit()\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/delete_config/","title":"delete_config","text":"<p>nornir_scrapli.tasks.netconf_delete_config</p>"},{"location":"reference/tasks/netconf/delete_config/#tasks.netconf.delete_config.netconf_delete_config","title":"<code>netconf_delete_config(task: Task, target: str = 'candidate') -&gt; Result</code>","text":"<p>Send a \"delete-config\" rcp to the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>target</code> <code>str</code> <p>configuration source to target; startup|candidate</p> <code>'candidate'</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the delete operation</p> Source code in <code>tasks/netconf/delete_config.py</code> <pre><code>def netconf_delete_config(\n    task: Task,\n    target: str = \"candidate\",\n) -&gt; Result:\n\"\"\"\n    Send a \"delete-config\" rcp to the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        target: configuration source to target; startup|candidate\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            delete operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.delete_config(target=target)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/discard/","title":"discard","text":"<p>nornir_scrapli.tasks.netconf_discard</p>"},{"location":"reference/tasks/netconf/discard/#tasks.netconf.discard.netconf_discard","title":"<code>netconf_discard(task: Task) -&gt; Result</code>","text":"<p>Discard the device config with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get operation</p> Source code in <code>tasks/netconf/discard.py</code> <pre><code>def netconf_discard(\n    task: Task,\n) -&gt; Result:\n\"\"\"\n    Discard the device config with scrapli_netconf\n\n    Args:\n        task: nornir task object\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.discard()\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/edit_config/","title":"edit_config","text":"<p>nornir_scrapli.tasks.netconf_edit_config</p>"},{"location":"reference/tasks/netconf/edit_config/#tasks.netconf.edit_config.netconf_edit_config","title":"<code>netconf_edit_config(task: Task, config: str, dry_run: Optional[bool] = None, diff: bool = False, target: str = 'running') -&gt; Result</code>","text":"<p>Edit config from the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>config</code> <code>str</code> <p>configuration to send to device</p> required <code>dry_run</code> <code>Optional[bool]</code> <p>if True config will be pushed and then discarded; will discard anything already pushed that has not been committed already, so be careful! :D; also note that this will only work if there is a candidate datastore -- meaning that, for example, with IOSXE with a target of \"running\" there is no way to discard the configuration as it will already have been written to the running datastore</p> <code>None</code> <code>diff</code> <code>bool</code> <p>capture/set diff of target datastore xml text of before/after edit config operation</p> <code>False</code> <code>target</code> <code>str</code> <p>configuration source to target; running|startup|candidate</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get_config operation</p> Source code in <code>tasks/netconf/edit_config.py</code> <pre><code>def netconf_edit_config(\n    task: Task,\n    config: str,\n    dry_run: Optional[bool] = None,\n    diff: bool = False,\n    target: str = \"running\",\n) -&gt; Result:\n\"\"\"\n    Edit config from the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        config: configuration to send to device\n        dry_run: if True config will be pushed and then discarded; will discard anything already\n            pushed that has *not* been committed already, so be careful! :D; also note that this\n            will only work if there is a candidate datastore -- meaning that, for example, with\n            IOSXE with a target of \"running\" there is no way to discard the configuration as it will\n            already have been written to the running datastore\n        diff: capture/set diff of target datastore xml text of before/after edit config operation\n        target: configuration source to target; running|startup|candidate\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get_config operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n\n    if diff:\n        original_config = scrapli_conn.get_config(source=target)\n\n    scrapli_response = scrapli_conn.edit_config(config=config, target=target)\n\n    if diff:\n        edited_config = scrapli_conn.get_config(source=target)\n        diff_result = diff_xml_text(original_config.result, edited_config.result)\n    else:\n        diff_result = \"\"\n\n    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run\n\n    if _task_dry_run:\n        scrapli_conn.discard()\n        changed = False\n    else:\n        changed = True\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=changed,\n        diff=diff_result,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/get/","title":"get","text":"<p>nornir_scrapli.tasks.netconf_get</p>"},{"location":"reference/tasks/netconf/get/#tasks.netconf.get.netconf_get","title":"<code>netconf_get(task: Task, filter_: str, filter_type: str = 'subtree') -&gt; Result</code>","text":"<p>Get from the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>filter_</code> <code>str</code> <p>string filter to apply to the get</p> required <code>filter_type</code> <code>str</code> <p>type of filter; subtree|xpath</p> <code>'subtree'</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get operation</p> Source code in <code>tasks/netconf/get.py</code> <pre><code>def netconf_get(\n    task: Task,\n    filter_: str,\n    filter_type: str = \"subtree\",\n) -&gt; Result:\n\"\"\"\n    Get from the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        filter_: string filter to apply to the get\n        filter_type: type of filter; subtree|xpath\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.get(filter_=filter_, filter_type=filter_type)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/get_config/","title":"get_config","text":"<p>nornir_scrapli.tasks.netconf_get_config</p>"},{"location":"reference/tasks/netconf/get_config/#tasks.netconf.get_config.netconf_get_config","title":"<code>netconf_get_config(task: Task, source: str = 'running', filter_: Optional[Union[str, List[str]]] = None, filter_type: str = 'subtree') -&gt; Result</code>","text":"<p>Get config from the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>source</code> <code>str</code> <p>configuration source to get; typically one of running|startup|candidate</p> <code>'running'</code> <code>filter_</code> <code>Optional[Union[str, List[str]]]</code> <p>string of filter(s) to apply to configuration</p> <code>None</code> <code>filter_type</code> <code>str</code> <p>type of filter; subtree|xpath</p> <code>'subtree'</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get_config operation</p> Source code in <code>tasks/netconf/get_config.py</code> <pre><code>def netconf_get_config(\n    task: Task,\n    source: str = \"running\",\n    filter_: Optional[Union[str, List[str]]] = None,\n    filter_type: str = \"subtree\",\n) -&gt; Result:\n\"\"\"\n    Get config from the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        source: configuration source to get; typically one of running|startup|candidate\n        filter_: string of filter(s) to apply to configuration\n        filter_type: type of filter; subtree|xpath\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get_config operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.get_config(\n        source=source, filter_=filter_, filter_type=filter_type\n    )\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/lock/","title":"lock","text":"<p>nornir_scrapli.tasks.netconf_lock</p>"},{"location":"reference/tasks/netconf/lock/#tasks.netconf.lock.netconf_lock","title":"<code>netconf_lock(task: Task, target: str) -&gt; Result</code>","text":"<p>Lock the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>target</code> <code>str</code> <p>configuration source to target; running|startup|candidate</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get operation</p> Source code in <code>tasks/netconf/lock.py</code> <pre><code>def netconf_lock(\n    task: Task,\n    target: str,\n) -&gt; Result:\n\"\"\"\n    Lock the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        target: configuration source to target; running|startup|candidate\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.lock(target=target)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/rpc/","title":"rpc","text":"<p>nornir_scrapli.tasks.netconf_rpc</p>"},{"location":"reference/tasks/netconf/rpc/#tasks.netconf.rpc.netconf_rpc","title":"<code>netconf_rpc(task: Task, filter_: str) -&gt; Result</code>","text":"<p>Send a \"bare\" rcp to the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>filter_</code> <code>str</code> <p>filter/rpc to execute</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the rpc operation</p> Source code in <code>tasks/netconf/rpc.py</code> <pre><code>def netconf_rpc(\n    task: Task,\n    filter_: str,\n) -&gt; Result:\n\"\"\"\n    Send a \"bare\" rcp to the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        filter_: filter/rpc to execute\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            rpc operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.rpc(filter_=filter_)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/unlock/","title":"unlock","text":"<p>nornir_scrapli.tasks.netconf_unlock</p>"},{"location":"reference/tasks/netconf/unlock/#tasks.netconf.unlock.netconf_unlock","title":"<code>netconf_unlock(task: Task, target: str) -&gt; Result</code>","text":"<p>Unlock the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>target</code> <code>str</code> <p>configuration source to target; running|startup|candidate</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get operation</p> Source code in <code>tasks/netconf/unlock.py</code> <pre><code>def netconf_unlock(\n    task: Task,\n    target: str,\n) -&gt; Result:\n\"\"\"\n    Unlock the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        target: configuration source to target; running|startup|candidate\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.unlock(target=target)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=True,\n    )\n    return result\n</code></pre>"},{"location":"reference/tasks/netconf/validate/","title":"validate","text":"<p>nornir_scrapli.tasks.netconf_validate</p>"},{"location":"reference/tasks/netconf/validate/#tasks.netconf.validate.netconf_validate","title":"<code>netconf_validate(task: Task, source: str) -&gt; Result</code>","text":"<p>Send a \"validate\" rcp to the device with scrapli_netconf</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>nornir task object</p> required <code>source</code> <code>str</code> <p>configuration source to validate; typically one of running|startup|candidate</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>nornir result object with Result.result value set the string result of the get operation</p> Source code in <code>tasks/netconf/validate.py</code> <pre><code>def netconf_validate(\n    task: Task,\n    source: str,\n) -&gt; Result:\n\"\"\"\n    Send a \"validate\" rcp to the device with scrapli_netconf\n\n    Args:\n        task: nornir task object\n        source: configuration source to validate; typically one of running|startup|candidate\n\n    Returns:\n        Result: nornir result object with Result.result value set the string result of the\n            get operation\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_conn = task.host.get_connection(\"scrapli_netconf\", task.nornir.config)\n    scrapli_response = scrapli_conn.validate(source=source)\n\n    result = ScrapliResult(\n        host=task.host,\n        result=process_command_result(scrapli_response=scrapli_response),\n        scrapli_response=scrapli_response,\n        changed=False,\n    )\n    return result\n</code></pre>"},{"location":"user_guide/available_functions/","title":"Available Functions","text":"<ul> <li>print_structured_result --    this function is very similar to the \"normal\"    <code>print_result</code> function that now ships with the <code>nornir_utils</code> library (historically with nornir \"core\"), except    it contains several  additional arguments, most importantly the <code>parser</code> argument allows you to select <code>textfsm</code>    or <code>genie</code> to decide which parser to use to parse the unstructured data stored in the results object. Please see the structured     results example here for more details.</li> </ul>"},{"location":"user_guide/available_tasks/","title":"Available Tasks","text":"<p>All tasks presented here are methods that live in <code>scrapli</code> or <code>scrapli_netconf</code> -- these tasks are simply \"wrapped \" in such a way that they may be used within the constructs of <code>nornir</code>! The links below link back to the <code>scrapli</code> or <code>scrapli_netconf</code> docs for the given method -- in all (or very nearly all?) cases, the same arguments that the  underlying library supports will be exposed to <code>nornir</code>!</p>"},{"location":"user_guide/available_tasks/#scrapli-core-tasks","title":"Scrapli \"core\" Tasks","text":"<ul> <li>get_prompt - Get the current prompt of the device</li> <li>send_command - Send a single command to the device</li> <li>send_commands - Send a list of commands to the device</li> <li>send_commands_from_file - Send a list of commands from a file to the device</li> <li>send_config - Send a configuration to the device</li> <li>send_configs - Send a list of configurations to the device</li> <li>send_configs_from_file - Send a list of configurations from a file to the device</li> <li>send_interactive -\"Interact\" with the device (handle prompts and inputs and things like that)</li> </ul>"},{"location":"user_guide/available_tasks/#scrapli-netconf-tasks","title":"Scrapli Netconf Tasks","text":"<p>Note that not all devices will support all operations!</p> <ul> <li>netconf_capabilities - Get list of capabilities as exchanged during netconf connection establishment</li> <li>netconf_commit - Commit the configuration on the device</li> <li>netconf_discard - Discard the configuration on the device</li> <li>netconf_edit_config - Edit the configuration on the device</li> <li>netconf_delete_config - Delete a given datastore on the device</li> <li>netconf_get - Get a subtree or xpath from the device</li> <li>netconf_get_config - Get the configuration from the device</li> <li>netconf_lock - Lock the datastore on the device</li> <li>netconf_unlock - Unlock the datastore on the device</li> <li>netconf_rpc - Send a \"bare\" RPC to the device</li> <li>netconf_validate - Execute the<code>validate</code> rpc against a given datastore</li> </ul>"},{"location":"user_guide/available_tasks/#scrapli-cfg-tasks","title":"Scrapli Cfg Tasks","text":"<ul> <li>cfg_abort_config - Abort a loaded candidate config</li> <li>cfg_commit_config - Commit a loaded candidate config</li> <li>cfg_diff_config - Diff a loaded candidate config</li> <li>cfg_get_config - Get a target config</li> <li>cfg_get_version - Get the device version string</li> <li>cfg_load_config - Load a candidate config</li> </ul>"},{"location":"user_guide/basic_usage/","title":"Basic Usage","text":""},{"location":"user_guide/basic_usage/#basic-informationusage","title":"Basic Information/Usage","text":"<p>Nornir has historically contained it's plugins within the actual Nornir codebase itself, this however has changed! As  of mid September 2020, Nornir 3.0.0 has been officially released -- this move to the 3.x.x version now expects   plugins to be external to the code base. If you are looking for pre 3.x.x support, please use the <code>2020.09.01</code> version.</p> <p>If you have used Nornir before (pre 3.x.x), this package should be very similar to what you already know. Since the  plugins used to live in Nornir you could simply import them from the appropriate package as such:</p> <pre><code>from nornir.plugins.tasks.networking import netconf_get_config\n</code></pre> <p>With nornir_scrapli you simply install this package along side \"regular\" Nornir, and import the tasks from  nornir_scrapli directly:</p> <pre><code>from nornir_scrapli.tasks import send_command\n</code></pre> <p>As soon as a nornir_scrapli task is imported, it (<code>nornir_scrapli</code>) will register as a connection, and things should  work as normal from there!</p> <p>The last important difference with nornir_scrapli is that in addition to the \"normal\" data in the Nornir Result  object, nornir_scrapli also assigns the scrapli <code>Response</code> object (or list of <code>Response</code> objects) to the   <code>scrapli_response</code> attribute. This means that you can access all of the \"normal\" scrapli response data from this    object -- including things like <code>elapsed_time</code> and <code>textfsm_parse_output</code>:</p> <pre><code>&gt;&gt;&gt; some_nornir_result[\"sea-ios-1\"].scrapli_response.elapsed_time\n0.039469\n&gt;&gt;&gt; some_nornir_result[\"sea-ios-1\"].scrapli_response.textfsm_parse_output()\n[[some structured data back from the device!]]\n</code></pre> <p>If you would like to continue using <code>print_result</code> like \"normal\" in nornir, but would like to see structured data (if  available) in the <code>print_result</code> output, you can use the nornir_scrapli <code>print_structured_result</code> function. This   function can be imported from the scrapli functions module:</p> <pre><code>from nornir_scrapli.functions import print_structured_result\n</code></pre> <p>This function acts pretty much exactly like the \"normal\" print result function, but will of course try to print the  structured result. By default this will try to use textfsm to parse results, but it is of course configurable via   the <code>parser</code> keyword argument. As scrapli will return an empty data structure if parsing fails, this may cause    tasks to look like they are getting skipped in the output (nornir's print result function does not print empty     lists), if you would like to fall back to printing the unparsed output you can do so by setting the      <code>fail_to_string</code> keyword argument to <code>True</code> as follows:</p> <pre><code>print_structured_result(my_agg_result, parser=\"genie\", fail_to_string=True)\n</code></pre>"},{"location":"user_guide/basic_usage/#using-different-transports","title":"Using Different Transports","text":"<p>nornir_scrapli supports all synchronous scrapli transport plugins. By default, the \"system\" transport will be used,  however you can change this in the <code>extras</code> section of your nornir inventory:</p> <pre><code>connection_options:\nscrapli:\nport: 22\nextras:\nssh_config_file: True\nauth_strict_key: False\ntransport: ssh2\n</code></pre> <p>Note that you will need to install <code>scrapli_ssh2</code> or <code>scrapli_paramiko</code> if you want to use those transport plugins!</p>"},{"location":"user_guide/installation/","title":"Installation","text":""},{"location":"user_guide/installation/#standard-installation","title":"Standard Installation","text":"<p>As outlined in the quick start, you should be able to pip install scrapli \"normally\":</p> <pre><code>pip install nornir-scrapli\n</code></pre>"},{"location":"user_guide/installation/#installing-current-master-branch","title":"Installing current master branch","text":"<p>To install from the source repositories master branch:</p> <pre><code>pip install git+https://github.com/scrapli/nornir_scrapli\n</code></pre>"},{"location":"user_guide/installation/#installing-current-develop-branch","title":"Installing current develop branch","text":"<p>To install from this repositories develop branch:</p> <pre><code>pip install -e git+https://github.com/scrapli/nornir_scrapli.git@develop#egg=nornir_scrapli\n</code></pre>"},{"location":"user_guide/installation/#installation-from-source","title":"Installation from Source","text":"<p>To install from source:</p> <pre><code>git clone https://github.com/scrapli/nornir_scrapli\ncd nornir_scrapli\npython setup.py install\n</code></pre>"},{"location":"user_guide/installation/#supported-platforms","title":"Supported Platforms","text":"<p>As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any  POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no   longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or    ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks     to use WSL/Cygwin instead of Windows.</p>"},{"location":"user_guide/project_details/","title":"Project Details","text":""},{"location":"user_guide/project_details/#what-is-nornir_scrapli","title":"What is nornir_scrapli","text":"<p>nornir_scrapli is scrapli (and scrapli netconf's) plugin for Nornir. Nearly all (synchronous) methods of scrapli are  available/exposed in nornir scrapli. So if you enjoy scrapli, but also want the built-in concurrency and inventory  management afforded by nornir, this is the place to be!</p>"},{"location":"user_guide/project_details/#supported-platforms","title":"Supported Platforms","text":"<p>nornir_scrapli supports the \"core\" scrapli drivers, the GenericDriver (for use with linux hosts generally speaking ), and the scrapli_community platforms as well! See scrapli core docs and the scrapli community docs for more info. The <code>platform</code> argument in the inventory data should use the \"normal\" NAPALM style platform names, <code>generic</code>, or the name of the  scrapli_community platform (i.e. <code>huawei_vrp</code>)). </p> <p>Example platform values (for inventory data):</p> <pre><code>platform: cisco_iosxe\nplatform: cisco_iosxr\nplatform: cisco_nxos\nplatform: arista_eos\nplatform: juniper_junos\nplatform: generic\nplatform: huawei_vrp\n</code></pre>"},{"location":"user_guide/project_details/#related-scrapli-libraries","title":"Related Scrapli Libraries","text":"<p>This repo is the nornir plugin for scrapli, however there are other libraries/repos in the scrapli family  -- here is a list/link to all of the other scrapli things!</p> <ul> <li>scrapli</li> <li>scrapli_netconf</li> <li>scrapli_community</li> <li>scrapli_cfg</li> <li>scrapli_replay</li> </ul>"},{"location":"user_guide/quickstart/","title":"Quick Start Guide","text":""},{"location":"user_guide/quickstart/#installation","title":"Installation","text":"<p>In most cases installation via pip is the simplest and best way to install nornir_scrapli.</p> <pre><code>pip install nornir-scrapli\n</code></pre>"},{"location":"user_guide/quickstart/#a-simple-example","title":"A Simple Example","text":"<p>Example config file:</p> <pre><code>---\ninventory:\nplugin: YAMLInventory\noptions:\nhost_file: \"nornir_data/hosts.yaml\"\ngroup_file: \"nornir_data/groups.yaml\"\ndefaults_file: \"nornir_data/defaults.yaml\"\n</code></pre> <p>Example inventory file (host/group/default, see \"real\" Nornir docs for lots more info!) -- please notice that there  is a <code>scrapli</code> and a <code>scrapli_netconf</code> connection type here!: <pre><code>---\niosxe-1:\nhostname: 172.18.0.11\nconnection_options:\nscrapli:\nplatform: cisco_iosxe\nport: 22\nextras:\nssh_config_file: True\nauth_strict_key: False\nscrapli_netconf:\nport: 830\nextras:\nssh_config_file: True\nauth_strict_key: False\n</code></pre></p> <p>NOTE: <code>scrapli-netconf</code> has no concept (at the moment!) of \"platforms\" - it simply implements RFC compliant  NETCONF RPCs, so you do not need to pass <code>iosxr</code>, <code>junos</code> or anything like that to the <code>scrapli_netconf</code> connection   options section!</p> <pre><code>from nornir import InitNornir\nfrom nornir_scrapli.tasks import (\n    get_prompt,\n    send_command,\n    send_configs\n)\n\nnr = InitNornir(config_file=\"nornir_data/config.yaml\")\n\nprompt_results = nr.run(task=get_prompt)\ncommand_results = nr.run(task=send_command, command=\"show version\")\nconfig_results = nr.run(\n    task=send_configs,\n    configs=[\"interface loopback123\", \"description nornir_scrapli was here\"],\n)\n\nprint(\"get_prompt result:\")\nprint(prompt_results[\"iosxe-1\"].result)\nprint(\"send_command result:\")\nprint(command_results[\"iosxe-1\"].result)\nprint(\"send_configs result:\")\nprint(config_results[\"iosxe-1\"].result)\n</code></pre> <pre><code>$ python my_scrapli_script.py\nget_prompt result:\n3560CX#\nsend_command result:\nCisco IOS Software, C3560CX Software (C3560CX-UNIVERSALK9-M), Version 15.2(4)E7, RELEASE SOFTWARE (fc2)\n&lt;SNIP&gt;\nsend_configs result:\n</code></pre> <p>Netconf tasks are imported from the same package and in the same fashion as the \"core\" <code>scrapli</code> tasks:</p> <pre><code>from nornir_scrapli.tasks import (\n    netconf_lock,\n    netconf_unlock,\n    netconf_edit_config,\n    netconf_get,\n    netconf_get_config,\n    netconf_rpc\n)\n</code></pre> <p>And are executed in the same fashion as well:</p> <pre><code>config = \"\"\"&lt;config&gt;\n    &lt;interfaces xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\"&gt;\n        &lt;interface&gt;\n            &lt;name&gt;GigabitEthernet1&lt;/name&gt;\n            &lt;description&gt;scrapli was here!&lt;/description&gt;\n        &lt;/interface&gt;\n    &lt;/interfaces&gt;\n&lt;/config&gt;\"\"\"\nresult = nr.run(task=netconf_edit_config, config=config)\nprint(result['iosxe1'][0].result)\nprint(result['iosxe1'][0].scrapli_response.xml_result)\n</code></pre> <p>When using the <code>scrapli-netconf</code> tasks the result object <code>result</code> will be the string of the returned data from the  device. As with all other <code>nornir-scrapli</code> results, the <code>scrapli_response</code> object will be assigned to the <code>Result</code> object and will contain all of the \"normal\" <code>scrapli</code> response object data (or <code>scrapli-netconf</code> response data  ), such as the <code>elapsed_time</code>, <code>raw_result</code>, <code>xml_result</code>, etc. -- you can see this in the above example!</p>"},{"location":"user_guide/quickstart/#additional-examples","title":"Additional Examples","text":"<ul> <li>NETCONF Usage</li> <li>Structured Data</li> </ul>"},{"location":"user_guide/versioning/","title":"Versioning","text":"<p>Please see the scrapli \"core\" here documentation for versioning information.</p>"}]}