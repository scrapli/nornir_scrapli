<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>nornir_scrapli.tasks API documentation</title>
<meta name="description" content="nornir_scrapli.tasks" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nornir_scrapli.tasks</code></h1>
</header>
<section id="section-intro">
<p>nornir_scrapli.tasks</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;nornir_scrapli.tasks&#34;&#34;&#34;
from nornir_scrapli.tasks.get_prompt import get_prompt
from nornir_scrapli.tasks.netconf_capabilities import netconf_capabilities
from nornir_scrapli.tasks.netconf_commit import netconf_commit
from nornir_scrapli.tasks.netconf_delete_config import netconf_delete_config
from nornir_scrapli.tasks.netconf_discard import netconf_discard
from nornir_scrapli.tasks.netconf_edit_config import netconf_edit_config
from nornir_scrapli.tasks.netconf_get import netconf_get
from nornir_scrapli.tasks.netconf_get_config import netconf_get_config
from nornir_scrapli.tasks.netconf_lock import netconf_lock
from nornir_scrapli.tasks.netconf_rpc import netconf_rpc
from nornir_scrapli.tasks.netconf_unlock import netconf_unlock
from nornir_scrapli.tasks.netconf_validate import netconf_validate
from nornir_scrapli.tasks.send_command import send_command
from nornir_scrapli.tasks.send_commands import send_commands
from nornir_scrapli.tasks.send_commands_from_file import send_commands_from_file
from nornir_scrapli.tasks.send_config import send_config
from nornir_scrapli.tasks.send_configs import send_configs
from nornir_scrapli.tasks.send_configs_from_file import send_configs_from_file
from nornir_scrapli.tasks.send_interactive import send_interactive

__all__ = (
    &#34;get_prompt&#34;,
    &#34;netconf_capabilities&#34;,
    &#34;netconf_commit&#34;,
    &#34;netconf_delete_config&#34;,
    &#34;netconf_discard&#34;,
    &#34;netconf_edit_config&#34;,
    &#34;netconf_get&#34;,
    &#34;netconf_get_config&#34;,
    &#34;netconf_lock&#34;,
    &#34;netconf_rpc&#34;,
    &#34;netconf_unlock&#34;,
    &#34;netconf_validate&#34;,
    &#34;send_command&#34;,
    &#34;send_commands&#34;,
    &#34;send_commands_from_file&#34;,
    &#34;send_config&#34;,
    &#34;send_configs&#34;,
    &#34;send_configs_from_file&#34;,
    &#34;send_interactive&#34;,
)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nornir_scrapli.tasks.get_prompt"><code class="name flex">
<span>def <span class="ident">get_prompt</span></span>(<span>task: nornir.core.task.Task) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Get current prompt from device using scrapli</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to current prompt</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prompt(task: Task) -&gt; Result:
    &#34;&#34;&#34;
    Get current prompt from device using scrapli

    Args:
        task: nornir task object

    Returns:
        Result: nornir result object with Result.result value set to current prompt

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)
    prompt = scrapli_conn.get_prompt()
    return Result(host=task.host, result=prompt, failed=False, changed=False)</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_capabilities"><code class="name flex">
<span>def <span class="ident">netconf_capabilities</span></span>(<span>task: nornir.core.task.Task) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the device config with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to a list of strings representing
the device capabilities</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_capabilities(
    task: Task,
) -&gt; Result:
    &#34;&#34;&#34;
    Retrieve the device config with scrapli_netconf

    Args:
        task: nornir task object

    Returns:
        Result: nornir result object with Result.result value set to a list of strings representing
            the device capabilities

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)

    result = Result(
        host=task.host,
        result=scrapli_conn.server_capabilities,
        failed=False,
        changed=False,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_commit"><code class="name flex">
<span>def <span class="ident">netconf_commit</span></span>(<span>task: nornir.core.task.Task) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Commit the device config with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_commit(
    task: Task,
) -&gt; Result:
    &#34;&#34;&#34;
    Commit the device config with scrapli_netconf

    Args:
        task: nornir task object

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.commit()

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_delete_config"><code class="name flex">
<span>def <span class="ident">netconf_delete_config</span></span>(<span>task: nornir.core.task.Task, target: str = 'candidate') ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send a "delete-config" rcp to the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
delete operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_delete_config(
    task: Task,
    target: str = &#34;candidate&#34;,
) -&gt; Result:
    &#34;&#34;&#34;
    Send a &#34;delete-config&#34; rcp to the device with scrapli_netconf

    Args:
        task: nornir task object
        target: configuration source to target; startup|candidate

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            delete operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.delete_config(target=target)

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_discard"><code class="name flex">
<span>def <span class="ident">netconf_discard</span></span>(<span>task: nornir.core.task.Task) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Discard the device config with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_discard(
    task: Task,
) -&gt; Result:
    &#34;&#34;&#34;
    Discard the device config with scrapli_netconf

    Args:
        task: nornir task object

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.discard()

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_edit_config"><code class="name flex">
<span>def <span class="ident">netconf_edit_config</span></span>(<span>task: nornir.core.task.Task, config: str, dry_run: Union[bool, NoneType] = None, diff: bool = False, target: str = 'running') ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Edit config from the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>config</code></strong></dt>
<dd>configuration to send to device</dd>
<dt><strong><code>dry_run</code></strong></dt>
<dd>if True config will be pushed and then discarded; will discard anything already
pushed that has <em>not</em> been committed already, so be careful! :D; also note that this
will only work if there is a candidate datastore &ndash; meaning that, for example, with
IOSXE with a target of "running" there is no way to discard the configuration as it will
already have been written to the running datastore</dd>
<dt><strong><code>diff</code></strong></dt>
<dd>capture/set diff of target datastore xml text of before/after edit config operation</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get_config operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_edit_config(
    task: Task,
    config: str,
    dry_run: Optional[bool] = None,
    diff: bool = False,
    target: str = &#34;running&#34;,
) -&gt; Result:
    &#34;&#34;&#34;
    Edit config from the device with scrapli_netconf

    Args:
        task: nornir task object
        config: configuration to send to device
        dry_run: if True config will be pushed and then discarded; will discard anything already
            pushed that has *not* been committed already, so be careful! :D; also note that this
            will only work if there is a candidate datastore -- meaning that, for example, with
            IOSXE with a target of &#34;running&#34; there is no way to discard the configuration as it will
            already have been written to the running datastore
        diff: capture/set diff of target datastore xml text of before/after edit config operation
        target: configuration source to target; running|startup|candidate

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get_config operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)

    if diff:
        original_config = scrapli_conn.get_config(source=target)

    scrapli_response = scrapli_conn.edit_config(config=config, target=target)

    if diff:
        edited_config = scrapli_conn.get_config(source=target)
        diff_result = diff_xml_text(original_config.result, edited_config.result)
    else:
        diff_result = &#34;&#34;

    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run

    if _task_dry_run:
        scrapli_conn.discard()
        changed = False
    else:
        changed = True

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=changed,
        diff=diff_result,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_get"><code class="name flex">
<span>def <span class="ident">netconf_get</span></span>(<span>task: nornir.core.task.Task, filter_: str, filter_type: str = 'subtree') ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Get from the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>filter_</code></strong></dt>
<dd>string filter to apply to the get</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_get(
    task: Task,
    filter_: str,
    filter_type: str = &#34;subtree&#34;,
) -&gt; Result:
    &#34;&#34;&#34;
    Get from the device with scrapli_netconf

    Args:
        task: nornir task object
        filter_: string filter to apply to the get
        filter_type: type of filter; subtree|xpath

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.get(filter_=filter_, filter_type=filter_type)

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=False,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_get_config"><code class="name flex">
<span>def <span class="ident">netconf_get_config</span></span>(<span>task: nornir.core.task.Task, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Get config from the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>source</code></strong></dt>
<dd>configuration source to get; typically one of running|startup|candidate</dd>
<dt><strong><code>filters</code></strong></dt>
<dd>string or list of strings of filters to apply to configuration</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get_config operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_get_config(
    task: Task,
    source: str = &#34;running&#34;,
    filters: Optional[Union[str, List[str]]] = None,
    filter_type: str = &#34;subtree&#34;,
) -&gt; Result:
    &#34;&#34;&#34;
    Get config from the device with scrapli_netconf

    Args:
        task: nornir task object
        source: configuration source to get; typically one of running|startup|candidate
        filters: string or list of strings of filters to apply to configuration
        filter_type: type of filter; subtree|xpath

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get_config operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.get_config(
        source=source, filters=filters, filter_type=filter_type
    )

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=False,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_lock"><code class="name flex">
<span>def <span class="ident">netconf_lock</span></span>(<span>task: nornir.core.task.Task, target: str) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Lock the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_lock(
    task: Task,
    target: str,
) -&gt; Result:
    &#34;&#34;&#34;
    Lock the device with scrapli_netconf

    Args:
        task: nornir task object
        target: configuration source to target; running|startup|candidate

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.lock(target=target)

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_rpc"><code class="name flex">
<span>def <span class="ident">netconf_rpc</span></span>(<span>task: nornir.core.task.Task, filter_: str) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send a "bare" rcp to the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>filter_</code></strong></dt>
<dd>filter/rpc to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
rpc operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_rpc(
    task: Task,
    filter_: str,
) -&gt; Result:
    &#34;&#34;&#34;
    Send a &#34;bare&#34; rcp to the device with scrapli_netconf

    Args:
        task: nornir task object
        filter_: filter/rpc to execute

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            rpc operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.rpc(filter_=filter_)

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_unlock"><code class="name flex">
<span>def <span class="ident">netconf_unlock</span></span>(<span>task: nornir.core.task.Task, target: str) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Unlock the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_unlock(
    task: Task,
    target: str,
) -&gt; Result:
    &#34;&#34;&#34;
    Unlock the device with scrapli_netconf

    Args:
        task: nornir task object
        target: configuration source to target; running|startup|candidate

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.unlock(target=target)

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.netconf_validate"><code class="name flex">
<span>def <span class="ident">netconf_validate</span></span>(<span>task: nornir.core.task.Task, source: str) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send a "validate" rcp to the device with scrapli_netconf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>source</code></strong></dt>
<dd>configuration source to validate; typically one of running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set the string result of the
get operation</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netconf_validate(
    task: Task,
    source: str,
) -&gt; Result:
    &#34;&#34;&#34;
    Send a &#34;validate&#34; rcp to the device with scrapli_netconf

    Args:
        task: nornir task object
        source: configuration source to validate; typically one of running|startup|candidate

    Returns:
        Result: nornir result object with Result.result value set the string result of the
            get operation

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli_netconf&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.validate(source=source)

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=False,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>task: nornir.core.task.Task, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, timeout_ops: Union[float, NoneType] = None) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send a single command to device using scrapli</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout ops value for this operation; only sets the timeout_ops value for
the duration of the operation, value is reset to initial value after operation is
completed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>scrapli nornir result object; almost identical to a "normal" nornir result object,
but contains an additional attribute "scrapli_response" that contains the original
response from scrapli</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(
    task: Task,
    command: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    timeout_ops: Optional[float] = None,
) -&gt; Result:
    &#34;&#34;&#34;
    Send a single command to device using scrapli

    Args:
        task: nornir task object
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for
            the duration of the operation, value is reset to initial value after operation is
            completed

    Returns:
        Result: scrapli nornir result object; almost identical to a &#34;normal&#34; nornir result object,
            but contains an additional attribute &#34;scrapli_response&#34; that contains the original
            response from scrapli

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.send_command(
        command=command,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        timeout_ops=timeout_ops,
    )

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=False,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>task: nornir.core.task.Task, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Union[float, NoneType] = None) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send a list of commands to device using scrapli</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results as of
current execution</dd>
<dt><strong><code>eager</code></strong></dt>
<dd>if eager is True we do not read until prompt is seen at each command sent to the
channel. Do <em>not</em> use this unless you know what you are doing as it is possible that
it can make scrapli less reliable!</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout ops value for this operation; only sets the timeout_ops value for
the duration of the operation, value is reset to initial value after operation is
completed. Note that this is the timeout value PER COMMAND sent, not for the total
of the commands being sent!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to returned scrapli Response
object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(
    task: Task,
    commands: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    eager: bool = False,
    timeout_ops: Optional[float] = None,
) -&gt; Result:
    &#34;&#34;&#34;
    Send a list of commands to device using scrapli

    Args:
        task: nornir task object
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results as of
            current execution
        eager: if eager is True we do not read until prompt is seen at each command sent to the
            channel. Do *not* use this unless you know what you are doing as it is possible that
            it can make scrapli less reliable!
        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for
            the duration of the operation, value is reset to initial value after operation is
            completed. Note that this is the timeout value PER COMMAND sent, not for the total
            of the commands being sent!

    Returns:
        Result: nornir result object with Result.result value set to returned scrapli Response
            object

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.send_commands(
        commands=commands,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        eager=eager,
        timeout_ops=timeout_ops,
    )

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=False,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.send_commands_from_file"><code class="name flex">
<span>def <span class="ident">send_commands_from_file</span></span>(<span>task: nornir.core.task.Task, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Union[float, NoneType] = None) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send a list of commands from a file to device using scrapli</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>file</code></strong></dt>
<dd>string path to file</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results as of
current execution</dd>
<dt><strong><code>eager</code></strong></dt>
<dd>if eager is True we do not read until prompt is seen at each command sent to the
channel. Do <em>not</em> use this unless you know what you are doing as it is possible that
it can make scrapli less reliable!</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout ops value for this operation; only sets the timeout_ops value for
the duration of the operation, value is reset to initial value after operation is
completed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to returned scrapli Response
object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands_from_file(
    task: Task,
    file: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    eager: bool = False,
    timeout_ops: Optional[float] = None,
) -&gt; Result:
    &#34;&#34;&#34;
    Send a list of commands from a file to device using scrapli

    Args:
        task: nornir task object
        file: string path to file
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results as of
            current execution
        eager: if eager is True we do not read until prompt is seen at each command sent to the
            channel. Do *not* use this unless you know what you are doing as it is possible that
            it can make scrapli less reliable!
        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for
            the duration of the operation, value is reset to initial value after operation is
            completed

    Returns:
        Result: nornir result object with Result.result value set to returned scrapli Response
            object

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.send_commands_from_file(
        file=file,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        eager=eager,
        timeout_ops=timeout_ops,
    )

    result = ScrapliResult(
        host=task.host,
        result=process_command_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=False,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.send_config"><code class="name flex">
<span>def <span class="ident">send_config</span></span>(<span>task: nornir.core.task.Task, config: str, dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send a config to device using scrapli</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>config</code></strong></dt>
<dd>string configuration to send to the device, supports sending multi-line strings</dd>
<dt><strong><code>dry_run</code></strong></dt>
<dd>Whether to apply changes or not; if dry run, will ensure that it is possible to
enter config mode, but will NOT send any configs</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results as of
current execution</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "configuration_exclusive" for IOSXRDriver, or "configuration_private" for
JunosDriver. You can also pass in a name of a configuration session such as
"my-config-session" if you have registered a session using the
"register_config_session" method of the EOSDriver or NXOSDriver.</dd>
<dt><strong><code>eager</code></strong></dt>
<dd>if eager is True we do not read until prompt is seen at each command sent to the
channel. Do <em>not</em> use this unless you know what you are doing as it is possible that
it can make scrapli less reliable!</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout ops value for this operation; only sets the timeout_ops value for
the duration of the operation, value is reset to initial value after operation is
completed. Note that this is the timeout value PER CONFIG sent, not for the total
of the configs being sent!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to returned scrapli Response
object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NornirScrapliNoConfigModeGenericDriver</code></dt>
<dd>If attempting to use this task function against a
host that is using the "generic" platform type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_config(
    task: Task,
    config: str,
    dry_run: Optional[bool] = None,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
    eager: bool = False,
    timeout_ops: Optional[float] = None,
) -&gt; Result:
    &#34;&#34;&#34;
    Send a config to device using scrapli

    Args:
        task: nornir task object
        config: string configuration to send to the device, supports sending multi-line strings
        dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to
            enter config mode, but will NOT send any configs
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results as of
            current execution
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
            JunosDriver. You can also pass in a name of a configuration session such as
            &#34;my-config-session&#34; if you have registered a session using the
            &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.
        eager: if eager is True we do not read until prompt is seen at each command sent to the
             channel. Do *not* use this unless you know what you are doing as it is possible that
             it can make scrapli less reliable!
        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for
            the duration of the operation, value is reset to initial value after operation is
            completed. Note that this is the timeout value PER CONFIG sent, not for the total
            of the configs being sent!

    Returns:
        Result: nornir result object with Result.result value set to returned scrapli Response
            object

    Raises:
        NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a
            host that is using the &#34;generic&#34; platform type

    &#34;&#34;&#34;
    if task.host.platform == &#34;generic&#34;:
        raise NornirScrapliNoConfigModeGenericDriver(&#34;No config mode for &#39;generic&#39; platform type&#34;)

    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)

    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run

    if _task_dry_run:
        # if dry run, try to acquire config mode then back out; do not send any configurations!
        scrapli_conn.acquire_priv(&#34;configuration&#34;)
        scrapli_conn.acquire_priv(scrapli_conn.default_desired_privilege_level)
        return ScrapliResult(host=task.host, result=None, scrapli_response=None, changed=False)

    scrapli_response = scrapli_conn.send_config(
        config=config,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        privilege_level=privilege_level,
        eager=eager,
        timeout_ops=timeout_ops,
    )

    result = ScrapliResult(
        host=task.host,
        result=process_config_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.send_configs"><code class="name flex">
<span>def <span class="ident">send_configs</span></span>(<span>task: nornir.core.task.Task, configs: List[str], dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send configs to device using scrapli</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>configs</code></strong></dt>
<dd>list of strings to send to device in config mode</dd>
<dt><strong><code>dry_run</code></strong></dt>
<dd>Whether to apply changes or not; if dry run, will ensure that it is possible to
enter config mode, but will NOT send any configs</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results as of
current execution</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "configuration_exclusive" for IOSXRDriver, or "configuration_private" for
JunosDriver. You can also pass in a name of a configuration session such as
"my-config-session" if you have registered a session using the
"register_config_session" method of the EOSDriver or NXOSDriver.</dd>
<dt><strong><code>eager</code></strong></dt>
<dd>if eager is True we do not read until prompt is seen at each command sent to the
channel. Do <em>not</em> use this unless you know what you are doing as it is possible that
it can make scrapli less reliable!</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout ops value for this operation; only sets the timeout_ops value for
the duration of the operation, value is reset to initial value after operation is
completed. Note that this is the timeout value PER CONFIG sent, not for the total
of the configs being sent!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to returned scrapli Response
object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NornirScrapliNoConfigModeGenericDriver</code></dt>
<dd>If attempting to use this task function against a
host that is using the "generic" platform type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_configs(
    task: Task,
    configs: List[str],
    dry_run: Optional[bool] = None,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
    eager: bool = False,
    timeout_ops: Optional[float] = None,
) -&gt; Result:
    &#34;&#34;&#34;
    Send configs to device using scrapli

    Args:
        task: nornir task object
        configs: list of strings to send to device in config mode
        dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to
            enter config mode, but will NOT send any configs
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results as of
            current execution
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
            JunosDriver. You can also pass in a name of a configuration session such as
            &#34;my-config-session&#34; if you have registered a session using the
            &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.
        eager: if eager is True we do not read until prompt is seen at each command sent to the
            channel. Do *not* use this unless you know what you are doing as it is possible that
            it can make scrapli less reliable!
        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for
            the duration of the operation, value is reset to initial value after operation is
            completed. Note that this is the timeout value PER CONFIG sent, not for the total
            of the configs being sent!

    Returns:
        Result: nornir result object with Result.result value set to returned scrapli Response
            object

    Raises:
        NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a
            host that is using the &#34;generic&#34; platform type

    &#34;&#34;&#34;
    if task.host.platform == &#34;generic&#34;:
        raise NornirScrapliNoConfigModeGenericDriver(&#34;No config mode for &#39;generic&#39; platform type&#34;)

    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)

    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run

    if _task_dry_run:
        # if dry run, try to acquire config mode then back out; do not send any configurations!
        scrapli_conn.acquire_priv(&#34;configuration&#34;)
        scrapli_conn.acquire_priv(scrapli_conn.default_desired_privilege_level)
        return ScrapliResult(host=task.host, result=None, scrapli_response=None, changed=False)

    scrapli_response = scrapli_conn.send_configs(
        configs=configs,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        privilege_level=privilege_level,
        eager=eager,
        timeout_ops=timeout_ops,
    )

    result = ScrapliResult(
        host=task.host,
        result=process_config_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.send_configs_from_file"><code class="name flex">
<span>def <span class="ident">send_configs_from_file</span></span>(<span>task: nornir.core.task.Task, file: str, dry_run: Union[bool, NoneType] = None, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Union[float, NoneType] = None) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send configs from a file to device using scrapli</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>file</code></strong></dt>
<dd>string path to file</dd>
<dt><strong><code>dry_run</code></strong></dt>
<dd>Whether to apply changes or not; if dry run, will ensure that it is possible to
enter config mode, but will NOT send any configs</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results as of
current execution</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "configuration_exclusive" for IOSXRDriver, or "configuration_private" for
JunosDriver. You can also pass in a name of a configuration session such as
"my-config-session" if you have registered a session using the
"register_config_session" method of the EOSDriver or NXOSDriver.</dd>
<dt><strong><code>eager</code></strong></dt>
<dd>if eager is True we do not read until prompt is seen at each command sent to the
channel. Do <em>not</em> use this unless you know what you are doing as it is possible that
it can make scrapli less reliable!</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout ops value for this operation; only sets the timeout_ops value for
the duration of the operation, value is reset to initial value after operation is
completed. Note that this is the timeout value PER CONFIG sent, not for the total
of the configs being sent!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to returned scrapli Response
object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NornirScrapliNoConfigModeGenericDriver</code></dt>
<dd>If attempting to use this task function against a
host that is using the "generic" platform type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_configs_from_file(
    task: Task,
    file: str,
    dry_run: Optional[bool] = None,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
    eager: bool = False,
    timeout_ops: Optional[float] = None,
) -&gt; Result:
    &#34;&#34;&#34;
    Send configs from a file to device using scrapli

    Args:
        task: nornir task object
        file: string path to file
        dry_run: Whether to apply changes or not; if dry run, will ensure that it is possible to
            enter config mode, but will NOT send any configs
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results as of
            current execution
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
            JunosDriver. You can also pass in a name of a configuration session such as
            &#34;my-config-session&#34; if you have registered a session using the
            &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.
        eager: if eager is True we do not read until prompt is seen at each command sent to the
            channel. Do *not* use this unless you know what you are doing as it is possible that
            it can make scrapli less reliable!
        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for
            the duration of the operation, value is reset to initial value after operation is
            completed. Note that this is the timeout value PER CONFIG sent, not for the total
            of the configs being sent!

    Returns:
        Result: nornir result object with Result.result value set to returned scrapli Response
            object

    Raises:
        NornirScrapliNoConfigModeGenericDriver: If attempting to use this task function against a
            host that is using the &#34;generic&#34; platform type

    &#34;&#34;&#34;
    if task.host.platform == &#34;generic&#34;:
        raise NornirScrapliNoConfigModeGenericDriver(&#34;No config mode for &#39;generic&#39; platform type&#34;)

    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)

    _task_dry_run = dry_run if dry_run is not None else task.global_dry_run

    if _task_dry_run:
        # if dry run, try to acquire config mode then back out; do not send any configurations!
        scrapli_conn.acquire_priv(&#34;configuration&#34;)
        scrapli_conn.acquire_priv(scrapli_conn.default_desired_privilege_level)
        return ScrapliResult(host=task.host, result=None, scrapli_response=None, changed=False)

    scrapli_response = scrapli_conn.send_configs_from_file(
        file=file,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        privilege_level=privilege_level,
        eager=eager,
        timeout_ops=timeout_ops,
    )

    result = ScrapliResult(
        host=task.host,
        result=process_config_result(scrapli_response=scrapli_response),
        scrapli_response=scrapli_response,
        changed=True,
    )
    return result</code></pre>
</details>
</dd>
<dt id="nornir_scrapli.tasks.send_interactive"><code class="name flex">
<span>def <span class="ident">send_interactive</span></span>(<span>task: nornir.core.task.Task, interact_events: List[Tuple[str, str, Union[bool, NoneType]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '', timeout_ops: Union[float, NoneType] = None) ‑> nornir.core.task.Result</span>
</code></dt>
<dd>
<div class="desc"><p>Send inputs in an interactive fashion using scrapli; usually used to handle prompts</p>
<p>Used to interact with devices where prompts change per input, and where inputs may be hidden
such as in the case of a password input. This can be used to respond to challenges from
devices such as the confirmation for the command "clear logging" on IOSXE devices for
example. You may have as many elements in the "interact_events" list as needed, and each
element of that list should be a tuple of two or three elements. The first element is always
the input to send as a string, the second should be the expected response as a string, and
the optional third a bool for whether or not the input is "hidden" (i.e. password input)
An example where we need this sort of capability:</p>
<pre><code>3560CX#copy flash: scp:
Source filename []? test1.txt
Address or name of remote host []? 172.31.254.100
Destination username [carl]?
Writing test1.txt
Password:
Password:
 Sink: C0644 639 test1.txt
!
639 bytes copied in 12.066 secs (53 bytes/sec)
3560CX#
</code></pre>
<p>To accomplish this we can use the following (in "native" scrapli):</p>
<pre><code>interact = conn.channel.send_inputs_interact(
    [
        (&quot;copy flash: scp:&quot;, &quot;Source filename []?&quot;, False),
        (&quot;test1.txt&quot;, &quot;Address or name of remote host []?&quot;, False),
        (&quot;172.31.254.100&quot;, &quot;Destination username [carl]?&quot;, False),
        (&quot;carl&quot;, &quot;Password:&quot;, False),
        (&quot;super_secure_password&quot;, prompt, True),
    ]
)
</code></pre>
<p>If we needed to deal with more prompts we could simply continue adding tuples to the list of
interact "events".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong></dt>
<dd>nornir task object</dd>
<dt><strong><code>interact_events</code></strong></dt>
<dd>list of tuples containing the "interactions" with the device
each list element must have an input and an expected response, and may have an
optional bool for the third and final element &ndash; the optional bool specifies if the
input that is sent to the device is "hidden" (ex: password), if the hidden param is
not provided it is assumed the input is "normal" (not hidden)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that, if present in final output, represent a
failed command/interaction</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of the privilege level to operate in</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout ops value for this operation; only sets the timeout_ops value for
the duration of the operation, value is reset to initial value after operation is
completed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result</code></dt>
<dd>nornir result object with Result.result value set to returned scrapli Response
object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_interactive(
    task: Task,
    interact_events: List[Tuple[str, str, Optional[bool]]],
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    privilege_level: str = &#34;&#34;,
    timeout_ops: Optional[float] = None,
) -&gt; Result:
    &#34;&#34;&#34;
    Send inputs in an interactive fashion using scrapli; usually used to handle prompts

    Used to interact with devices where prompts change per input, and where inputs may be hidden
    such as in the case of a password input. This can be used to respond to challenges from
    devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
    example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
    element of that list should be a tuple of two or three elements. The first element is always
    the input to send as a string, the second should be the expected response as a string, and
    the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)
    An example where we need this sort of capability:

    ```
    3560CX#copy flash: scp:
    Source filename []? test1.txt
    Address or name of remote host []? 172.31.254.100
    Destination username [carl]?
    Writing test1.txt
    Password:
    Password:
     Sink: C0644 639 test1.txt
    !
    639 bytes copied in 12.066 secs (53 bytes/sec)
    3560CX#
    ```

    To accomplish this we can use the following (in &#34;native&#34; scrapli):

    ```
    interact = conn.channel.send_inputs_interact(
        [
            (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
            (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
            (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
            (&#34;carl&#34;, &#34;Password:&#34;, False),
            (&#34;super_secure_password&#34;, prompt, True),
        ]
    )
    ```

    If we needed to deal with more prompts we could simply continue adding tuples to the list of
    interact &#34;events&#34;.

    Args:
        task: nornir task object
        interact_events: list of tuples containing the &#34;interactions&#34; with the device
            each list element must have an input and an expected response, and may have an
            optional bool for the third and final element -- the optional bool specifies if the
            input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
            not provided it is assumed the input is &#34;normal&#34; (not hidden)
        failed_when_contains: list of strings that, if present in final output, represent a
            failed command/interaction
        privilege_level: name of the privilege level to operate in
        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for
            the duration of the operation, value is reset to initial value after operation is
            completed

    Returns:
        Result: nornir result object with Result.result value set to returned scrapli Response
            object

    Raises:
        N/A

    &#34;&#34;&#34;
    scrapli_conn = task.host.get_connection(&#34;scrapli&#34;, task.nornir.config)
    scrapli_response = scrapli_conn.send_interactive(
        interact_events=interact_events,
        failed_when_contains=failed_when_contains,
        privilege_level=privilege_level,
        timeout_ops=timeout_ops,
    )

    result = Result(
        host=task.host,
        result=scrapli_response,
        failed=scrapli_response.failed,
        changed=True,
    )
    setattr(result, &#34;scrapli_response&#34;, scrapli_response)
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nornir_scrapli" href="../index.html">nornir_scrapli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nornir_scrapli.tasks.get_prompt" href="#nornir_scrapli.tasks.get_prompt">get_prompt</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_capabilities" href="#nornir_scrapli.tasks.netconf_capabilities">netconf_capabilities</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_commit" href="#nornir_scrapli.tasks.netconf_commit">netconf_commit</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_delete_config" href="#nornir_scrapli.tasks.netconf_delete_config">netconf_delete_config</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_discard" href="#nornir_scrapli.tasks.netconf_discard">netconf_discard</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_edit_config" href="#nornir_scrapli.tasks.netconf_edit_config">netconf_edit_config</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_get" href="#nornir_scrapli.tasks.netconf_get">netconf_get</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_get_config" href="#nornir_scrapli.tasks.netconf_get_config">netconf_get_config</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_lock" href="#nornir_scrapli.tasks.netconf_lock">netconf_lock</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_rpc" href="#nornir_scrapli.tasks.netconf_rpc">netconf_rpc</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_unlock" href="#nornir_scrapli.tasks.netconf_unlock">netconf_unlock</a></code></li>
<li><code><a title="nornir_scrapli.tasks.netconf_validate" href="#nornir_scrapli.tasks.netconf_validate">netconf_validate</a></code></li>
<li><code><a title="nornir_scrapli.tasks.send_command" href="#nornir_scrapli.tasks.send_command">send_command</a></code></li>
<li><code><a title="nornir_scrapli.tasks.send_commands" href="#nornir_scrapli.tasks.send_commands">send_commands</a></code></li>
<li><code><a title="nornir_scrapli.tasks.send_commands_from_file" href="#nornir_scrapli.tasks.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="nornir_scrapli.tasks.send_config" href="#nornir_scrapli.tasks.send_config">send_config</a></code></li>
<li><code><a title="nornir_scrapli.tasks.send_configs" href="#nornir_scrapli.tasks.send_configs">send_configs</a></code></li>
<li><code><a title="nornir_scrapli.tasks.send_configs_from_file" href="#nornir_scrapli.tasks.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="nornir_scrapli.tasks.send_interactive" href="#nornir_scrapli.tasks.send_interactive">send_interactive</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>